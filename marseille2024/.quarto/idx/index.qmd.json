{"title":"Differentiable and distributed Particle-Mesh n-body simulations","markdown":{"yaml":{"title":"Differentiable and distributed Particle-Mesh n-body simulations","author":"Wassim Kabalan, François Lanusse, Alexandre Boucaud","footer":"LSST France, 2024","format":{"revealjs":{"theme":["default","css/custom.scss"],"incremental":false,"transition":"slide","background-transition":"slide","presentation-size":"max-scale","template-partials":["css/title-slide.html"]}},"output":"revealjs","code-block-border-left":"#31BAE9","title-slide-attributes":{"data-background-image":"assets/lsst_bg.jpg","data-background-size":"fill","data-background-opacity":"0.5"},"logo1":"![](assets/AIM.png){fig-align=\"center\"width=10%} ![](assets/APC.png){fig-align=\"center\" width=10%}"},"headingText":"Traditional cosmological inference","containsRefs":false,"markdown":"\n\n\n<br />\n\n### Bayesian inference in cosmology\n\n- We need to infer the cosmological parameters $\\theta$ that generated an observartion $x$\n\n<font size=\"4\">$$p(\\theta | x ) \\propto \\underbrace{p(x | \\theta)}_{\\mathrm{likelihood}} \\ \\underbrace{p(\\theta)}_{\\mathrm{prior}}$$</font>\n\n\n:::: {.columns}\n\n::: {.column width=\"40%\"}\n\n::: {.fragment fragment-index=1 .fade-in-then-out }\n\n![](assets/hsc-corr-function.png){.absolute top=180 left=25 width=\"300\"}\n\n:::\n\n::: {.fragment fragment-index=2}\n\n![](assets/hsc_constraints.png){.absolute top=200 left=25 width=\"350\"}\n\n:::\n\n:::\n\n::: {.column width=\"60%\"}\n\n::: {.fragment fragment-index=1}\n<br />\n ➢  &emsp;Compute **summary statistics** based on the 2-point correlation function of the shear field\n:::\n\n::: {.fragment fragment-index=2}\n<br />\n ➢  &emsp;Run an **MCMC** chain to recover the posterior distribution of the cosmological parameters, using an **analytical likelihood**\n:::\n\n:::\n\n::::\n\n<br />\n\n::: {.fragment fragment-index=3}\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\nLimitations\n::::\n\n::::{.solutionbox-body}\n- Simple summary statistics assume Gaussianity\n- The need to compute an analytical likelihood\n::::\n\n:::\n\n:::\n\n---\n\n### Beyond 2 point statistics : Full field inference\n\n<br />\n\n\n![](assets/simu.png){.nostretch fig-align=\"center\" width=\"600px\"}\n\n\n::: {.fragment}\n\n➕  &emsp;No longer need to compute the likelihood analytically\n<br />\n<br />\n➖ &emsp;We need to infer the joint posterior $p(\\theta, z | x)$ before marginalization to get $p(\\theta | x) = \\int p(\\theta, z | x) \\, dz$\n\n::: \n\n::: {.fragment}\n\n:::{.solutionbox}\n\n\n::::{.solutionbox-header}\nPossible solutions\n::::\n\n::::{.solutionbox-body}\n- **Hamiltonian Monte Carlo**\n- **Variational Inference**\n- **Dimensionality reduction using Fisher Information Matrix**\n\n*All require a differentiable fast forward model*\n\n::::\n\n:::\n\n:::\n\n::: {.fragment}\n\n➢  &emsp; We need a fast, differentiable and precise cosmological simulations\n\n:::\n\n---\n\n### Fast Particle-mesh simulations\n\n<br />\n<br />\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n#### Numerical scheme\n\n::: {.fragment fragment-index=1}\n\n➢  &emsp;Interpolate particles on a grid to estimate mass density\n\n:::\n\n::: {.fragment fragment-index=2}\n\n➢  &emsp;Estimate gravitational force on grid points by FFT\n\n:::\n\n::: {.fragment fragment-index=3}\n\n➢  &emsp;Interpolate forces back on particles\n\n:::\n\n::: {.fragment fragment-index=4}\n\n➢  &emsp;Update particle velocity and positions, and iterate \n\n:::\n\n::: \n\n::: {.column width=\"50%\"}\n\n:::{r-stack}\n\n\n::: {.fragment fragment-index=1 .fade-in-then-out}\n\n![](assets/FastPM_Init.gif){.absolute top=50 left=400 width=\"800\"}\n\n:::\n\n\n::: {.fragment fragment-index=2 .fade-in-then-out}\n\n![](assets/FastPM_LPT.gif){.absolute top=50 left=400 width=\"800\"}\n\n\n[$\\begin{array}{c}{{\\nabla^{2}\\phi=-4\\pi G\\rho}}\\\\\\\\ {{f(\\vec{k})=i\\vec{k}k^{-2}\\rho(\\vec{k})}}\\end{array}$]{.absolute top=500 right=160}\n\n::: \n\n::: {.fragment fragment-index=3}\n\n![](assets/FastPM_ODE.gif){.absolute top=50 left=400 width=\"800\"}\n\n\n\n:::\n\n:::\n\n\n::: \n\n:::: \n\n::: {.fragment fragment-index=5 }\n\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n\n:::{.solutionbox}\n\n::::{.solutionbox-body}\n\n- Fast and simple, at the cost of approximating short range interactions. \n- It is essentially a series of FFTs and interpolations\n- It is differentiable and can run on GPUs\n\n::::\n\n:::\n\n:::\n\n---\n\n## JAX : Automatic differentiation and Hardware acceleration {auto-animate=\"true\"}\n\n![](assets/JaxLogo.png){.absolute top=60 right=25 width=200px}\n\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n``` python\nimport numpy as np\n\n\ndef multiply_and_add(a, b, c):\n    return np.dot(a, b) + c\n\n\na, b, c = np.random.normal(size=(3, 32, 32))\nresult = multiply_and_add(a, b, c)\n```\n<br />\n\n::: {.fragment fragment-index=1 .fade-in-then-out }\n\n``` python\nimport jax\nimport jax.numpy as jnp\n\n\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c) \n\n```\n\n::: \n\n\n## JAX : Automatic differentiation and Hardware acceleration {auto-animate=\"true\"}\n\n![](assets/JaxLogo.png){.absolute top=60 right=25 width=200px}\n\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n\n``` python\nimport jax\nimport jax.numpy as jnp\n\n\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c) \n\n```\n\n## JAX : Automatic differentiation and Hardware acceleration {auto-animate=\"true\"}\n\n![](assets/JaxLogo.png){.absolute top=60 right=25 width=200px}\n\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n\n``` python\nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c) \ngradient = jax.grad(multiply_and_add)(a, b, c)\n\n```\n\n<br />\n<br />\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\n\nJAX : Numpy + Autograd + GPU\n\n::::\n\n::::{.solutionbox-body}\n\n - <span style=\"color:violet;\">jax.grad</span> uses automatic differentiation to compute the gradient of the function\n - <span style=\"color:violet;\">jax.jit</span> compiles the function to run on GPUs\n\n::::\n\n:::\n---\n\n### JaxPM : A differentiable Particle-Mesh simulation\n\n#### FastPM simulation in a few lines of code\n\n<p style=\"display: flex; align-items: center; position: absolute; top: 10px; left: 700px;\">\n  <img src=\"assets/github_logo.png\" alt=\"GitHub Logo\" style=\"width: 5%; margin-right: 10px;\">\n  <a href=\"https://github.com/DifferentiableUniverseInitiative/JaxPM\">DifferentiableUniverseInitiative/JaxPM</a>\n</p>\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n<div style=\"font-size: 83%\">\n\n<div style=\"position: absolute; top: 75px; left: 0px;\">\n\n```{.python }\nmesh_shape = [64, 64, 64]\nbox_size = [64., 64., 64.]\nsnapshots = jnp.linspace(0.1, 1., 2)\n\n@jax.jit\ndef run_simulation(omega_c, sigma8):\n    # Create a small function to generate the matter power spectrum\n    k = jnp.logspace(-4, 1, 128)\n    pk = jc.power.linear_matter_power(\n        jc.Planck15(Omega_c=omega_c, sigma8=sigma8), k)\n    pk_fn = lambda x: jc.scipy.interpolate.interp(x.reshape([-1]), k, pk\n                                                  ).reshape(x.shape)\n\n    # Create initial conditions\n    initial_conditions = linear_field(mesh_shape,\n                                      box_size,\n                                      pk_fn,\n                                      seed=jax.random.PRNGKey(0))\n\n    # Create particles\n    particles = jnp.stack(jnp.meshgrid(*[jnp.arange(s) for s in mesh_shape]),\n                          axis=-1).reshape([-1, 3])\n\n    cosmo = jc.Planck15(Omega_c=omega_c, sigma8=sigma8)\n\n    # Initial displacement\n    dx, p, f = lpt(cosmo, initial_conditions, particles, 0.1)\n    field = dx + particles\n\n    # Evolve the simulation forward\n    ode_fn = make_ode_fn(mesh_shape)\n    term = ODETerm(lambda t, state, args: jnp.stack(ode_fn(state, t, args), axis=0))\n    solver = Dopri5()\n\n    stepsize_controller = PIDController(rtol=1e-7, atol=1e-7)\n    res = diffeqsolve(term, solver, t0=0.1, t1=1., dt0=0.01, y0=jnp.stack([dx, p],axis=0), \n                       args=(cosmo , kvec),\n                       stepsize_controller=stepsize_controller,\n                       saveat=SaveAt(ts=snapshots))\n\n    # Return the simulation volume at requested\n    return field, res, initial_conditions\n\nfield, res, initial_conditions = run_simulation(0.25, 0.8)\n\n\n```\n\n\n</div>\n\n</div>\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment fragment-index=1} \n\n![](assets/FastPM_ODE3D.gif){.absolute top=50 left=400 width=\"900\"}\n\n:::\n\n:::\n\n::::\n\n::: {.fragment fragment-index=7} \n\n\n[***Is everything solved ?***]{.absolute top=650 left=100}\n\n::: \n\n---\n\n### Fast Particle-mesh scaling\n\n#### Current FastPM implementation\n\n:::aside\n\n\n:::\n\n\n➢  &emsp;(Poqueres et al. 2021) : $64^3$ mesh size, on a 1000 Mpc/h box\n\n➢  &emsp;(Li et al. 2022) : $512^3$ mesh size,  using [pmwd](https://github.com/eelregit/pmwd)\n\n::: {.fragment fragment-index=1 }\n\n![](assets/depict_gathered.png){.absolute top=30 right=0 width=\"20%\"}\n\n::: \n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.r-stack}\n\n::: {.fragment fragment-index=1 .fade-in-then-out}\n\n![Initial Conditions with a 1024 mesh](assets/initial_conditions_1024.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=2 .fade-in-then-out}\n\n![Initial Conditions with a 512 mesh](assets/initial_conditions_512.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=3 .fade-in-then-out}\n\n![Initial Conditions with a 256 mesh](assets/initial_conditions_256.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=4 .fade-in-then-out}\n\n![Initial Conditions with a 128 mesh](assets/initial_conditions_128.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=5 .fade-in-then-out}\n\n![Initial Conditions with a 64 mesh](assets/initial_conditions_64.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=6}\n\n<!-- 512 -->\n\n![Power spectrum comparison](assets/power_spec.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n:::\n\n::: \n\n::: {.column width=\"50%\"}\n\n::: {.r-stack}\n\n::: {.fragment fragment-index=1 .fade-in-then-out}\n\n![Final field with a 1024 mesh](assets/LPT_density_field_z0_1024.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=2 .fade-in-then-out}\n\n![Final field with a 512 mesh](assets/LPT_density_field_z0_512.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=3 .fade-in-then-out}\n\n![Final field with a 256 mesh](assets/LPT_density_field_z0_256.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=4 .fade-in-then-out}\n\n![Final field with a 128 mesh](assets/LPT_density_field_z0_128.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=5 .fade-in-then-out}\n\n![Final field with a 64 mesh](assets/LPT_density_field_z0_64.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=6}\n\n![Final field with a 1024 mesh](assets/LPT_density_field_z0_1024.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: \n\n:::\n\n::::\n\n::: {.fragment fragment-index=9}\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\n\nScaling\n\n::::\n\n::::{.solutionbox-body}\n\nWe need a fast, differentiable and <span style=\"color:violet;\">Scalable</span> Particle-Mesh simulation\n\n::::\n\n::: \n\n::: \n\n\n\n---\n\n### Scaling on modern hardware\n\n#### Size of a FastPM simulation\n\n\n![](assets/simulation_gpu_sizes.png){.nostretch fig-align=\"center\" width=\"650\"}\n\n\n::: {.fragment .fragment-index-1}\n\n\n#### Scaling on multiple GPUs\n\n\n::: {layout=\"[20 , 30 , 50]\" layout-valign=\"bottom\" layout-align=\"bottom\"}\n\n![Single GPU (80GB)](assets/jax-1gpu.png){width=\"55%\"}\n\n\n![Single Node (8x80GB)](assets/jax-1node.png){width=\"55%\"}\n\n\n![Muti Node ( $\\infty$ )](assets/jax-multi-node.png){width=\"90%\"}\n\n::: \n\n:::\n---\n\n\n## Distributed Fast Fourier Transform {auto-animate=\"true\"}\n\n➢  &emsp;only operation that requires communication is the FFT\n\n<br/>\n\n#### Jaxdecomp\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n```python\nimport jax\nimport jax.numpy as jnp\n\nfield = jax.random.normal(jax.random.PRNGKey(0), (1024, 1024, 1024))\nk_field = jnp.fft.fftn(field)\n```\n\n:::\n\n::: {.column width=\"50%\"}\n\n:::\n\n::::\n\n---\n\n## Distributed Fast Fourier Transform {auto-animate=\"true\"}\n\n➢  &emsp;only operation that requires communication is the FFT\n\n<br/>\n\n#### Jaxdecomp\n\n<p style=\"display: flex; align-items: center; position: absolute; top: 10px; left: 600px;\">\n  <img src=\"assets/github_logo.png\" alt=\"GitHub Logo\" style=\"width: 5%; margin-right: 10px;\">\n  <a href=\"https://github.com/DifferentiableUniverseInitiative/jaxDecomp\">DifferentiableUniverseInitiative/jaxDecomp</a>\n</p>\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n```python\nimport jax\nimport jax.numpy as jnp\nimport jaxdecomp\n\ndevices = mesh_utils.create_device_mesh((2, 2))\nmesh = jax.sharding.Mesh(devices, axis_names=('x', 'y'))\nsharding = jax.sharding.NamedSharding(mesh, P('x', 'y'))\n\n# Create gaussian field distributed across the mesh\nfield = jax.make_array_from_single_device_arrays(\n    shape=mesh_shape,\n    sharding=sharding,\n    arrays=[jax.random.normal(jax.random.PRNGKey(rank), (512, 512, 1024))])\n\nk_field = jaxdecomp.fft.pfft3d(field)\n\n\n```\n\n:::{.fragment fragment-index=3}\n\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\n\nJaxDecomp features\n\n::::\n\n::::{.solutionbox-body}\n\n➢  &emsp;jaxDecomp supports 2D and 1D decompositions\n\n➢  &emsp;Works for multi-node FFTs\n\n➢  &emsp;is differentiable\n\n➢  &emsp;The package is also provided as a standalone library\n\n\n::::\n\n:::\n\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n:::{.fragment fragment-index=2}\n\n![](assets/decomp2d.gif){.absolute top=50 left=400 width=\"900\"}\n\n:::\n\n::: \n\n::::\n\n---\n\n### Scaling of Distributed FFT operations\n\n![](assets/single_precision_gpus.png){.absolute top=50 left=0 width=\"1000\"}\n\n\n---\n\n## Halo exchange in distributed simulations\n\n::: {.fragment fragment-index=1 .fade-in-then-out}\n\n![](assets/depict_gathered.png){.absolute top=30 right=20 width=\"20%\"}\n\n::: \n\n::: {.fragment fragment-index=2 }\n\n![](assets/depict_split.png){.absolute top=30 right=20 width=\"20%\"}\n\n::: \n\n:::{.r-stack}\n\n:::{.fragment fragment-index=1 .fade-in-then-out}\n\n![Initial Field](assets/initial_conditions_1024.png){.nostretch  width=\"400px\"}\n\n:::\n\n:::{.fragment fragment-index=2 .fade-in-then-out}\n\n:::{layout=\"[[1] , [1] , [1] , [1]]\" layout-valign=\"center\" layout-align=\"center\"}\n\n![First slice](assets/initial_conditions_0_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Second slice](assets/initial_conditions_1_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Third slice](assets/initial_conditions_2_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Fourth slice](assets/initial_conditions_3_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n:::\n\n:::\n\n:::{.fragment fragment-index=3 .fade-in-then-out}\n\n:::{layout=\"[[1] , [1] , [1] , [1]]\" layout-valign=\"center\" layout-align=\"center\"}\n\n![First slice](assets/LPT_density_field_z0_0_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Second slice](assets/LPT_density_field_z0_1_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Third slice](assets/LPT_density_field_z0_2_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Fourth slice](assets/LPT_density_field_z0_3_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n:::\n\n:::\n\n:::{.fragment fragment-index=4 .fade-in-then-out}\n\n![LPT Field](assets/LPT_density_field_z0_1024_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n:::\n\n\n:::{.fragment fragment-index=5}\n\n![LPT Field](assets/LPT_density_field_z0_1024.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n:::\n\n:::\n\n:::{.fragment fragment-index=5}\n\n<div style=\"position: absolute; top: 75px; left: 0px; width: 500px; font-size: 100%\">\n\n```python\nfrom jaxdecomp import halo_exchange\n\nhalo_size = 128\nfield = halo_exchange(field, halo_extent=halo_size)\n\n```\n\n</div>\n\n:::\n\n---\n\n### Distributed JaxPM Particle-Mesh simulations \n\n\n![](assets/LPT_density_field_z0_2048.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\n\nDistributed FastPM simulations\n\n::::\n\n::::{.solutionbox-body}\n\n➢  &emsp;Multi host version of <span style=\"color:violet;\">JaxPM</span> using <span style=\"color:violet;\">jaxDecomp</span>\n\n➢  &emsp;For a $2048^3$ LPT simulation ran on 16 GPUs runs in under a second on Jean-Zay super computer\n\n➢  &emsp;We aim to run a $8192^3$ Particle-mesh simulation on 160 GPUs \n\n::::\n\n:::\n\n\n---\n\n\n## Conclusion {background-image=\"assets/LPT_density_field_z0_2048.png\"}\n\n<br/>\n<br/>\n<br/>\n<br/>\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\n\nDistruibuted Particle-Mesh simulations for cosmological inference\n\n::::\n\n::::{.solutionbox-body}\n\n - A shift from analytical likelihoods to full field inference\n   - The need for fast differentiable simulators\n   - Particle-Mesh as simulators for full field inference\n   - Distributed fourrier transforms that work on multi-node HPC using <span style=\"color:violet;\">jaxDecomp</span>\n   - Highly scalable LPT simulations using <span style=\"color:violet;\">JaxPM</span>\n - Still subject to some challenges \n   - Some issues with the ODE solving step\n   - Only Euler gives decent results.\n\n::::\n\n\n:::\n\n---\n\n## \n\n---\n","srcMarkdownNoYaml":"\n\n## Traditional cosmological inference\n\n<br />\n\n### Bayesian inference in cosmology\n\n- We need to infer the cosmological parameters $\\theta$ that generated an observartion $x$\n\n<font size=\"4\">$$p(\\theta | x ) \\propto \\underbrace{p(x | \\theta)}_{\\mathrm{likelihood}} \\ \\underbrace{p(\\theta)}_{\\mathrm{prior}}$$</font>\n\n\n:::: {.columns}\n\n::: {.column width=\"40%\"}\n\n::: {.fragment fragment-index=1 .fade-in-then-out }\n\n![](assets/hsc-corr-function.png){.absolute top=180 left=25 width=\"300\"}\n\n:::\n\n::: {.fragment fragment-index=2}\n\n![](assets/hsc_constraints.png){.absolute top=200 left=25 width=\"350\"}\n\n:::\n\n:::\n\n::: {.column width=\"60%\"}\n\n::: {.fragment fragment-index=1}\n<br />\n ➢  &emsp;Compute **summary statistics** based on the 2-point correlation function of the shear field\n:::\n\n::: {.fragment fragment-index=2}\n<br />\n ➢  &emsp;Run an **MCMC** chain to recover the posterior distribution of the cosmological parameters, using an **analytical likelihood**\n:::\n\n:::\n\n::::\n\n<br />\n\n::: {.fragment fragment-index=3}\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\nLimitations\n::::\n\n::::{.solutionbox-body}\n- Simple summary statistics assume Gaussianity\n- The need to compute an analytical likelihood\n::::\n\n:::\n\n:::\n\n---\n\n### Beyond 2 point statistics : Full field inference\n\n<br />\n\n\n![](assets/simu.png){.nostretch fig-align=\"center\" width=\"600px\"}\n\n\n::: {.fragment}\n\n➕  &emsp;No longer need to compute the likelihood analytically\n<br />\n<br />\n➖ &emsp;We need to infer the joint posterior $p(\\theta, z | x)$ before marginalization to get $p(\\theta | x) = \\int p(\\theta, z | x) \\, dz$\n\n::: \n\n::: {.fragment}\n\n:::{.solutionbox}\n\n\n::::{.solutionbox-header}\nPossible solutions\n::::\n\n::::{.solutionbox-body}\n- **Hamiltonian Monte Carlo**\n- **Variational Inference**\n- **Dimensionality reduction using Fisher Information Matrix**\n\n*All require a differentiable fast forward model*\n\n::::\n\n:::\n\n:::\n\n::: {.fragment}\n\n➢  &emsp; We need a fast, differentiable and precise cosmological simulations\n\n:::\n\n---\n\n### Fast Particle-mesh simulations\n\n<br />\n<br />\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n#### Numerical scheme\n\n::: {.fragment fragment-index=1}\n\n➢  &emsp;Interpolate particles on a grid to estimate mass density\n\n:::\n\n::: {.fragment fragment-index=2}\n\n➢  &emsp;Estimate gravitational force on grid points by FFT\n\n:::\n\n::: {.fragment fragment-index=3}\n\n➢  &emsp;Interpolate forces back on particles\n\n:::\n\n::: {.fragment fragment-index=4}\n\n➢  &emsp;Update particle velocity and positions, and iterate \n\n:::\n\n::: \n\n::: {.column width=\"50%\"}\n\n:::{r-stack}\n\n\n::: {.fragment fragment-index=1 .fade-in-then-out}\n\n![](assets/FastPM_Init.gif){.absolute top=50 left=400 width=\"800\"}\n\n:::\n\n\n::: {.fragment fragment-index=2 .fade-in-then-out}\n\n![](assets/FastPM_LPT.gif){.absolute top=50 left=400 width=\"800\"}\n\n\n[$\\begin{array}{c}{{\\nabla^{2}\\phi=-4\\pi G\\rho}}\\\\\\\\ {{f(\\vec{k})=i\\vec{k}k^{-2}\\rho(\\vec{k})}}\\end{array}$]{.absolute top=500 right=160}\n\n::: \n\n::: {.fragment fragment-index=3}\n\n![](assets/FastPM_ODE.gif){.absolute top=50 left=400 width=\"800\"}\n\n\n\n:::\n\n:::\n\n\n::: \n\n:::: \n\n::: {.fragment fragment-index=5 }\n\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n\n:::{.solutionbox}\n\n::::{.solutionbox-body}\n\n- Fast and simple, at the cost of approximating short range interactions. \n- It is essentially a series of FFTs and interpolations\n- It is differentiable and can run on GPUs\n\n::::\n\n:::\n\n:::\n\n---\n\n## JAX : Automatic differentiation and Hardware acceleration {auto-animate=\"true\"}\n\n![](assets/JaxLogo.png){.absolute top=60 right=25 width=200px}\n\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n``` python\nimport numpy as np\n\n\ndef multiply_and_add(a, b, c):\n    return np.dot(a, b) + c\n\n\na, b, c = np.random.normal(size=(3, 32, 32))\nresult = multiply_and_add(a, b, c)\n```\n<br />\n\n::: {.fragment fragment-index=1 .fade-in-then-out }\n\n``` python\nimport jax\nimport jax.numpy as jnp\n\n\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c) \n\n```\n\n::: \n\n\n## JAX : Automatic differentiation and Hardware acceleration {auto-animate=\"true\"}\n\n![](assets/JaxLogo.png){.absolute top=60 right=25 width=200px}\n\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n\n``` python\nimport jax\nimport jax.numpy as jnp\n\n\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c) \n\n```\n\n## JAX : Automatic differentiation and Hardware acceleration {auto-animate=\"true\"}\n\n![](assets/JaxLogo.png){.absolute top=60 right=25 width=200px}\n\n<br />\n<br />\n<br />\n<br />\n<br />\n<br />\n\n\n``` python\nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c) \ngradient = jax.grad(multiply_and_add)(a, b, c)\n\n```\n\n<br />\n<br />\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\n\nJAX : Numpy + Autograd + GPU\n\n::::\n\n::::{.solutionbox-body}\n\n - <span style=\"color:violet;\">jax.grad</span> uses automatic differentiation to compute the gradient of the function\n - <span style=\"color:violet;\">jax.jit</span> compiles the function to run on GPUs\n\n::::\n\n:::\n---\n\n### JaxPM : A differentiable Particle-Mesh simulation\n\n#### FastPM simulation in a few lines of code\n\n<p style=\"display: flex; align-items: center; position: absolute; top: 10px; left: 700px;\">\n  <img src=\"assets/github_logo.png\" alt=\"GitHub Logo\" style=\"width: 5%; margin-right: 10px;\">\n  <a href=\"https://github.com/DifferentiableUniverseInitiative/JaxPM\">DifferentiableUniverseInitiative/JaxPM</a>\n</p>\n\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n<div style=\"font-size: 83%\">\n\n<div style=\"position: absolute; top: 75px; left: 0px;\">\n\n```{.python }\nmesh_shape = [64, 64, 64]\nbox_size = [64., 64., 64.]\nsnapshots = jnp.linspace(0.1, 1., 2)\n\n@jax.jit\ndef run_simulation(omega_c, sigma8):\n    # Create a small function to generate the matter power spectrum\n    k = jnp.logspace(-4, 1, 128)\n    pk = jc.power.linear_matter_power(\n        jc.Planck15(Omega_c=omega_c, sigma8=sigma8), k)\n    pk_fn = lambda x: jc.scipy.interpolate.interp(x.reshape([-1]), k, pk\n                                                  ).reshape(x.shape)\n\n    # Create initial conditions\n    initial_conditions = linear_field(mesh_shape,\n                                      box_size,\n                                      pk_fn,\n                                      seed=jax.random.PRNGKey(0))\n\n    # Create particles\n    particles = jnp.stack(jnp.meshgrid(*[jnp.arange(s) for s in mesh_shape]),\n                          axis=-1).reshape([-1, 3])\n\n    cosmo = jc.Planck15(Omega_c=omega_c, sigma8=sigma8)\n\n    # Initial displacement\n    dx, p, f = lpt(cosmo, initial_conditions, particles, 0.1)\n    field = dx + particles\n\n    # Evolve the simulation forward\n    ode_fn = make_ode_fn(mesh_shape)\n    term = ODETerm(lambda t, state, args: jnp.stack(ode_fn(state, t, args), axis=0))\n    solver = Dopri5()\n\n    stepsize_controller = PIDController(rtol=1e-7, atol=1e-7)\n    res = diffeqsolve(term, solver, t0=0.1, t1=1., dt0=0.01, y0=jnp.stack([dx, p],axis=0), \n                       args=(cosmo , kvec),\n                       stepsize_controller=stepsize_controller,\n                       saveat=SaveAt(ts=snapshots))\n\n    # Return the simulation volume at requested\n    return field, res, initial_conditions\n\nfield, res, initial_conditions = run_simulation(0.25, 0.8)\n\n\n```\n\n\n</div>\n\n</div>\n\n:::\n\n::: {.column width=\"50%\"}\n\n::: {.fragment fragment-index=1} \n\n![](assets/FastPM_ODE3D.gif){.absolute top=50 left=400 width=\"900\"}\n\n:::\n\n:::\n\n::::\n\n::: {.fragment fragment-index=7} \n\n\n[***Is everything solved ?***]{.absolute top=650 left=100}\n\n::: \n\n---\n\n### Fast Particle-mesh scaling\n\n#### Current FastPM implementation\n\n:::aside\n\n\n:::\n\n\n➢  &emsp;(Poqueres et al. 2021) : $64^3$ mesh size, on a 1000 Mpc/h box\n\n➢  &emsp;(Li et al. 2022) : $512^3$ mesh size,  using [pmwd](https://github.com/eelregit/pmwd)\n\n::: {.fragment fragment-index=1 }\n\n![](assets/depict_gathered.png){.absolute top=30 right=0 width=\"20%\"}\n\n::: \n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n::: {.r-stack}\n\n::: {.fragment fragment-index=1 .fade-in-then-out}\n\n![Initial Conditions with a 1024 mesh](assets/initial_conditions_1024.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=2 .fade-in-then-out}\n\n![Initial Conditions with a 512 mesh](assets/initial_conditions_512.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=3 .fade-in-then-out}\n\n![Initial Conditions with a 256 mesh](assets/initial_conditions_256.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=4 .fade-in-then-out}\n\n![Initial Conditions with a 128 mesh](assets/initial_conditions_128.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=5 .fade-in-then-out}\n\n![Initial Conditions with a 64 mesh](assets/initial_conditions_64.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=6}\n\n<!-- 512 -->\n\n![Power spectrum comparison](assets/power_spec.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n:::\n\n::: \n\n::: {.column width=\"50%\"}\n\n::: {.r-stack}\n\n::: {.fragment fragment-index=1 .fade-in-then-out}\n\n![Final field with a 1024 mesh](assets/LPT_density_field_z0_1024.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=2 .fade-in-then-out}\n\n![Final field with a 512 mesh](assets/LPT_density_field_z0_512.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=3 .fade-in-then-out}\n\n![Final field with a 256 mesh](assets/LPT_density_field_z0_256.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=4 .fade-in-then-out}\n\n![Final field with a 128 mesh](assets/LPT_density_field_z0_128.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=5 .fade-in-then-out}\n\n![Final field with a 64 mesh](assets/LPT_density_field_z0_64.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: {.fragment fragment-index=6}\n\n![Final field with a 1024 mesh](assets/LPT_density_field_z0_1024.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n::: \n\n::: \n\n:::\n\n::::\n\n::: {.fragment fragment-index=9}\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\n\nScaling\n\n::::\n\n::::{.solutionbox-body}\n\nWe need a fast, differentiable and <span style=\"color:violet;\">Scalable</span> Particle-Mesh simulation\n\n::::\n\n::: \n\n::: \n\n\n\n---\n\n### Scaling on modern hardware\n\n#### Size of a FastPM simulation\n\n\n![](assets/simulation_gpu_sizes.png){.nostretch fig-align=\"center\" width=\"650\"}\n\n\n::: {.fragment .fragment-index-1}\n\n\n#### Scaling on multiple GPUs\n\n\n::: {layout=\"[20 , 30 , 50]\" layout-valign=\"bottom\" layout-align=\"bottom\"}\n\n![Single GPU (80GB)](assets/jax-1gpu.png){width=\"55%\"}\n\n\n![Single Node (8x80GB)](assets/jax-1node.png){width=\"55%\"}\n\n\n![Muti Node ( $\\infty$ )](assets/jax-multi-node.png){width=\"90%\"}\n\n::: \n\n:::\n---\n\n\n## Distributed Fast Fourier Transform {auto-animate=\"true\"}\n\n➢  &emsp;only operation that requires communication is the FFT\n\n<br/>\n\n#### Jaxdecomp\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n```python\nimport jax\nimport jax.numpy as jnp\n\nfield = jax.random.normal(jax.random.PRNGKey(0), (1024, 1024, 1024))\nk_field = jnp.fft.fftn(field)\n```\n\n:::\n\n::: {.column width=\"50%\"}\n\n:::\n\n::::\n\n---\n\n## Distributed Fast Fourier Transform {auto-animate=\"true\"}\n\n➢  &emsp;only operation that requires communication is the FFT\n\n<br/>\n\n#### Jaxdecomp\n\n<p style=\"display: flex; align-items: center; position: absolute; top: 10px; left: 600px;\">\n  <img src=\"assets/github_logo.png\" alt=\"GitHub Logo\" style=\"width: 5%; margin-right: 10px;\">\n  <a href=\"https://github.com/DifferentiableUniverseInitiative/jaxDecomp\">DifferentiableUniverseInitiative/jaxDecomp</a>\n</p>\n\n:::: {.columns}\n\n::: {.column width=\"50%\"}\n\n```python\nimport jax\nimport jax.numpy as jnp\nimport jaxdecomp\n\ndevices = mesh_utils.create_device_mesh((2, 2))\nmesh = jax.sharding.Mesh(devices, axis_names=('x', 'y'))\nsharding = jax.sharding.NamedSharding(mesh, P('x', 'y'))\n\n# Create gaussian field distributed across the mesh\nfield = jax.make_array_from_single_device_arrays(\n    shape=mesh_shape,\n    sharding=sharding,\n    arrays=[jax.random.normal(jax.random.PRNGKey(rank), (512, 512, 1024))])\n\nk_field = jaxdecomp.fft.pfft3d(field)\n\n\n```\n\n:::{.fragment fragment-index=3}\n\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\n\nJaxDecomp features\n\n::::\n\n::::{.solutionbox-body}\n\n➢  &emsp;jaxDecomp supports 2D and 1D decompositions\n\n➢  &emsp;Works for multi-node FFTs\n\n➢  &emsp;is differentiable\n\n➢  &emsp;The package is also provided as a standalone library\n\n\n::::\n\n:::\n\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n:::{.fragment fragment-index=2}\n\n![](assets/decomp2d.gif){.absolute top=50 left=400 width=\"900\"}\n\n:::\n\n::: \n\n::::\n\n---\n\n### Scaling of Distributed FFT operations\n\n![](assets/single_precision_gpus.png){.absolute top=50 left=0 width=\"1000\"}\n\n\n---\n\n## Halo exchange in distributed simulations\n\n::: {.fragment fragment-index=1 .fade-in-then-out}\n\n![](assets/depict_gathered.png){.absolute top=30 right=20 width=\"20%\"}\n\n::: \n\n::: {.fragment fragment-index=2 }\n\n![](assets/depict_split.png){.absolute top=30 right=20 width=\"20%\"}\n\n::: \n\n:::{.r-stack}\n\n:::{.fragment fragment-index=1 .fade-in-then-out}\n\n![Initial Field](assets/initial_conditions_1024.png){.nostretch  width=\"400px\"}\n\n:::\n\n:::{.fragment fragment-index=2 .fade-in-then-out}\n\n:::{layout=\"[[1] , [1] , [1] , [1]]\" layout-valign=\"center\" layout-align=\"center\"}\n\n![First slice](assets/initial_conditions_0_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Second slice](assets/initial_conditions_1_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Third slice](assets/initial_conditions_2_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Fourth slice](assets/initial_conditions_3_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n:::\n\n:::\n\n:::{.fragment fragment-index=3 .fade-in-then-out}\n\n:::{layout=\"[[1] , [1] , [1] , [1]]\" layout-valign=\"center\" layout-align=\"center\"}\n\n![First slice](assets/LPT_density_field_z0_0_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Second slice](assets/LPT_density_field_z0_1_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Third slice](assets/LPT_density_field_z0_2_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n![Fourth slice](assets/LPT_density_field_z0_3_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n:::\n\n:::\n\n:::{.fragment fragment-index=4 .fade-in-then-out}\n\n![LPT Field](assets/LPT_density_field_z0_1024_no_halo.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n:::\n\n\n:::{.fragment fragment-index=5}\n\n![LPT Field](assets/LPT_density_field_z0_1024.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n:::\n\n:::\n\n:::{.fragment fragment-index=5}\n\n<div style=\"position: absolute; top: 75px; left: 0px; width: 500px; font-size: 100%\">\n\n```python\nfrom jaxdecomp import halo_exchange\n\nhalo_size = 128\nfield = halo_exchange(field, halo_extent=halo_size)\n\n```\n\n</div>\n\n:::\n\n---\n\n### Distributed JaxPM Particle-Mesh simulations \n\n\n![](assets/LPT_density_field_z0_2048.png){.nostretch fig-align=\"center\" width=\"400px\"}\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\n\nDistributed FastPM simulations\n\n::::\n\n::::{.solutionbox-body}\n\n➢  &emsp;Multi host version of <span style=\"color:violet;\">JaxPM</span> using <span style=\"color:violet;\">jaxDecomp</span>\n\n➢  &emsp;For a $2048^3$ LPT simulation ran on 16 GPUs runs in under a second on Jean-Zay super computer\n\n➢  &emsp;We aim to run a $8192^3$ Particle-mesh simulation on 160 GPUs \n\n::::\n\n:::\n\n\n---\n\n\n## Conclusion {background-image=\"assets/LPT_density_field_z0_2048.png\"}\n\n<br/>\n<br/>\n<br/>\n<br/>\n\n:::{.solutionbox}\n\n::::{.solutionbox-header}\n\nDistruibuted Particle-Mesh simulations for cosmological inference\n\n::::\n\n::::{.solutionbox-body}\n\n - A shift from analytical likelihoods to full field inference\n   - The need for fast differentiable simulators\n   - Particle-Mesh as simulators for full field inference\n   - Distributed fourrier transforms that work on multi-node HPC using <span style=\"color:violet;\">jaxDecomp</span>\n   - Highly scalable LPT simulations using <span style=\"color:violet;\">JaxPM</span>\n - Still subject to some challenges \n   - Some issues with the ODE solving step\n   - Only Euler gives decent results.\n\n::::\n\n\n:::\n\n---\n\n## \n\n---\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":"revealjs","warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","incremental":false,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.5.43","auto-stretch":true,"title":"Differentiable and distributed Particle-Mesh n-body simulations","author":"Wassim Kabalan, François Lanusse, Alexandre Boucaud","footer":"LSST France, 2024","code-block-border-left":"#31BAE9","title-slide-attributes":{"data-background-image":"assets/lsst_bg.jpg","data-background-size":"fill","data-background-opacity":"0.5"},"logo1":"![](assets/AIM.png){fig-align=\"center\"width=10%} ![](assets/APC.png){fig-align=\"center\" width=10%}","theme":["default","css/custom.scss"],"transition":"slide","backgroundTransition":"slide","presentation-size":"max-scale","template-partials":["css/title-slide.html"]}}},"projectFormats":["html"]}