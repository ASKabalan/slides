---
title: "Differentiable and distributed Particle-Mesh n-body simulations"

author: "Wassim Kabalan"
format:
  revealjs:
    theme: [default , css/custom.scss]
    incremental: false   
    transition: slide
    background-transition: slide

code-block-border-left: "#31BAE9"
title-slide-attributes:
  data-background-image: "assets/lsst_bg.jpg"
  data-background-size: fill
  data-background-opacity: "0.5"
---


## Traditional cosmological inference

<br />

### Bayesian inference in cosmology

- We need to infer the cosmological parameters $\theta$ that generated an observartion $x$

<font size="4">$$p(\theta | x ) \propto \underbrace{p(x | \theta)}_{\mathrm{likelihood}} \ \underbrace{p(\theta)}_{\mathrm{prior}}$$</font>


:::: {.columns}

::: {.column width="40%"}

::: {.fragment fragment-index=1 .fade-in-then-out }

![](assets/hsc-corr-function.png){.absolute top=180 left=25 width="300"}

:::

::: {.fragment fragment-index=2}

![](assets/hsc_constraints.png){.absolute top=200 left=25 width="350"}

:::

:::

::: {.column width="60%"}

::: {.fragment fragment-index=1}
<br />
 ➢  &emsp;Compute **summary statistics** based on the 2-point correlation function of the shear field
:::

::: {.fragment fragment-index=2}
<br />
 ➢  &emsp;Run an **MCMC** chain to recover the posterior distribution of the cosmological parameters, using an **analytical likelihood**
:::

:::

::::

<br />

::: {.fragment fragment-index=3}

:::{.solutionbox}

::::{.solutionbox-header}
Limitations
::::

::::{.solutionbox-body}
- Simple summary statistics assume Gaussianity
- The need to compute an analytical likelihood
::::

:::

:::

---

### Beyond 2 point statistics : Full field inference

<br />


![](assets/simu.png){.nostretch fig-align="center" width="600px"}


::: {.fragment}

➕  &emsp;No longer need to compute the likelihood analytically
<br />
<br />
➖ &emsp;We need to infer the joint posterior $p(\theta, z | x)$ before marginalization to get $p(\theta | x) = \int p(\theta, z | x) \, dz$

::: 

::: {.fragment}

:::{.solutionbox}


::::{.solutionbox-header}
Possible solutions
::::

::::{.solutionbox-body}
- **Hamiltonian Monte Carlo**
- **Variational Inference**
- **Dimensionality reduction using Fisher Information Matrix**

*All require a differentiable fast forward model*

::::

:::

:::

::: {.fragment}

➢  &emsp; We need a fast, differentiable and precise cosmological simulations

:::

---

### Fast Particle-mesh simulations

<br />
<br />

:::: {.columns}

::: {.column width="50%"}

#### Numerical scheme

::: {.fragment fragment-index=1}

➢  &emsp;Interpolate particles on a grid to estimate mass density

:::

::: {.fragment fragment-index=2}

➢  &emsp;Estimate gravitational force on grid points by FFT

:::

::: {.fragment fragment-index=3}

➢  &emsp;Interpolate forces back on particles

:::

::: {.fragment fragment-index=4}

➢  &emsp;Update particle velocity and positions, and iterate 

:::

::: 

::: {.column width="50%"}

::: {style="text-align: center;"}


::: {.fragment fragment-index=1 .fade-in-then-out}

![](assets/FastPM_Init.gif){.absolute top=50 left=400 width="800"}


:::


::: {.fragment fragment-index=2 .fade-in-then-out}

![](assets/FastPM_LPT.gif){.absolute top=50 left=400 width="800"}


[$\begin{array}{c}{{\nabla^{2}\phi=-4\pi G\rho}}\\\\ {{f(\vec{k})=i\vec{k}k^{-2}\rho(\vec{k})}}\end{array}$]{.absolute top=500 right=160}

::: 

::: {.fragment fragment-index=3}

![](assets/FastPM_ODE.gif){.absolute top=50 left=400 width="800"}



:::

:::


::: 

:::: 

::: {.fragment fragment-index=5 }

<br />
<br />
<br />
<br />
<br />
<br />


:::{.solutionbox}

::::{.solutionbox-body}

- Fast and simple, at the cost of approximating short range interactions. 
- It is essentially a series of FFTs and interpolations
- It is differentiable and can run on GPUs

::::

:::

:::

---

## JAX : Automatic differentiation and Hardware acceleration {auto-animate="true"}

![](assets/JaxLogo.png){.absolute top=60 right=25 width=200px}

<br />
<br />
<br />
<br />
<br />
<br />

``` python
import numpy as np


def multiply_and_add(a, b, c):
    return np.dot(a, b) + c


a, b, c = np.random.normal(size=(3, 32, 32))
result = multiply_and_add(a, b, c)
```
<br />

::: {.fragment fragment-index=1 .fade-in-then-out }

``` python
import jax
import jax.numpy as jnp


def multiply_and_add(a, b, c):
    return jnp.dot(a, b) + c


key = jax.random.PRNGKey(0)
a, b, c = jax.random.normal(key, (3, 32, 32))

result = multiply_and_add(a, b, c) 

```

::: 


## JAX : Automatic differentiation and Hardware acceleration {auto-animate="true"}

![](assets/JaxLogo.png){.absolute top=60 right=25 width=200px}

<br />
<br />
<br />
<br />
<br />
<br />


``` python
import jax
import jax.numpy as jnp


def multiply_and_add(a, b, c):
    return jnp.dot(a, b) + c


key = jax.random.PRNGKey(0)
a, b, c = jax.random.normal(key, (3, 32, 32))

result = multiply_and_add(a, b, c) 

```

## JAX : Automatic differentiation and Hardware acceleration {auto-animate="true"}

![](assets/JaxLogo.png){.absolute top=60 right=25 width=200px}

<br />
<br />
<br />
<br />
<br />
<br />


``` python
import jax
import jax.numpy as jnp

@jax.jit
def multiply_and_add(a, b, c):
    return jnp.dot(a, b) + c


key = jax.random.PRNGKey(0)
a, b, c = jax.random.normal(key, (3, 32, 32))

result = multiply_and_add(a, b, c) 
gradient = jax.grad(multiply_and_add)(a, b, c)

```

<br />
<br />

:::{.solutionbox}

::::{.solutionbox-header}

JAX : Numpy + Autograd + GPU

::::

::::{.solutionbox-body}

 - <span style="color:violet;">jax.grad</span> uses automatic differentiation to compute the gradient of the function
 - <span style="color:violet;">jax.jit</span> compiles the function to run on GPUs

::::

:::
---

### JaxPM : A differentiable Particle-Mesh simulation

#### FastPM simulation in a few lines of code

<p style="display: flex; align-items: center; position: absolute; top: 10px; left: 700px;">
  <img src="assets/github_logo.png" alt="GitHub Logo" style="width: 5%; margin-right: 10px;">
  <a href="https://github.com/DifferentiableUniverseInitiative/JaxPM">DifferentiableUniverseInitiative/JaxPM</a>
</p>


:::: {.columns}

::: {.column width="50%"}

<div style="font-size: 85%">

<div style="position: absolute; top: 100px; left: 0px;">

```{.python }
mesh_shape = [64, 64, 64]
box_size = [64., 64., 64.]
snapshots = jnp.linspace(0.1, 1., 2)

@jax.jit
def run_simulation(omega_c, sigma8):
    # Create a small function to generate the matter power spectrum
    k = jnp.logspace(-4, 1, 128)
    pk = jc.power.linear_matter_power(
        jc.Planck15(Omega_c=omega_c, sigma8=sigma8), k)
    pk_fn = lambda x: jc.scipy.interpolate.interp(x.reshape([-1]), k, pk
                                                  ).reshape(x.shape)

    # Create initial conditions
    initial_conditions = linear_field(mesh_shape,
                                      box_size,
                                      pk_fn,
                                      seed=jax.random.PRNGKey(0))

    # Create particles
    particles = jnp.stack(jnp.meshgrid(*[jnp.arange(s) for s in mesh_shape]),
                          axis=-1).reshape([-1, 3])

    cosmo = jc.Planck15(Omega_c=omega_c, sigma8=sigma8)

    # Initial displacement
    dx, p, f = lpt(cosmo, initial_conditions, particles, 0.1)
    field = dx + particles

    # Evolve the simulation forward
    ode_fn = make_ode_fn(mesh_shape)
    term = ODETerm(lambda t, state, args: jnp.stack(ode_fn(state, t, args), axis=0))
    solver = Dopri5()

    stepsize_controller = PIDController(rtol=1e-7, atol=1e-7)
    res = diffeqsolve(term, solver, t0=0.1, t1=1., dt0=0.01, y0=jnp.stack([dx, p],axis=0), 
                       args=(cosmo , kvec),
                       stepsize_controller=stepsize_controller,
                       saveat=SaveAt(ts=snapshots))

    # Return the simulation volume at requested
    return field, res, initial_conditions

field, res, initial_conditions = run_simulation(0.25, 0.8)

```
</div>

</div>

:::

::: {.column width="50%"}

::: {.fragment fragment-index=1} 



![](assets/FastPM_ODE3D.gif){.absolute top=50 left=400 width="900"}

:::

:::

::::

::: {.fragment fragment-index=7} 


[***Is everything solved ?***]{.absolute top=650 left=100}

::: 

---

### Fast Particle-mesh scaling

#### Current FastPM implementation

:::aside


:::


➢  &emsp;(Poqueres et al. 2021) : $64^3$ mesh size, on a 1000 Mpc/h box

➢  &emsp;(Li et al. 2022) : $512^3$ mesh size,  using [pmwd](https://github.com/eelregit/pmwd)


:::: {.columns}

::: {.column width="50%"}

::: {.fragment fragment-index=1 .fade-in-then-out}

512 image

::: 

::: {.fragment fragment-index=2 .fade-in-then-out}

256 image

::: 

::: {.fragment fragment-index=3 .fade-in-then-out}

128 image

::: 

::: {.fragment fragment-index=4 .fade-in-then-out}

64 image

::: 

::: {.fragment fragment-index=5 .fade-in-then-out}

512 PowerSpec

::: 

::: {.fragment fragment-index=6 .fade-in-then-out}

256 PowerSpec

::: 

::: {.fragment fragment-index=7 .fade-in-then-out}

128 PowerSpec

::: 

::: {.fragment fragment-index=8}

64 PowerSpec

::: 

::: 

::: {.column width="50%"}

::: {.fragment fragment-index=1 .fade-in-then-out}


512 image

::: 

::: {.fragment fragment-index=2 .fade-in-then-out}

256 image

::: 

::: {.fragment fragment-index=3 .fade-in-then-out}

128 image

::: 

::: {.fragment fragment-index=4 .fade-in-then-out}

64 image

::: 

::: {.fragment fragment-index=5 .fade-in-then-out}


512 image

::: 

::: {.fragment fragment-index=6 .fade-in-then-out}

256 image

::: 

::: {.fragment fragment-index=7 .fade-in-then-out}

128 image

::: 

::: {.fragment fragment-index=8}

64 image

::: 


::: 

::::

::: {.fragment fragment-index=9}

:::{.solutionbox}

::::{.solutionbox-header}

Scaling

::::

::::{.solutionbox-body}

We need a fast, differentiable and <span style="color:violet;">distributed</span> Particle-Mesh simulation

::::

::: 

::: 



---

### Scaling on modern hardware

#### Size of a FastPM simulation


:::{.fragment .fragment-index-2}

![](assets/gpu_memory_sizes.png){.absolute top=75 right=50 width="400"}


![](assets/simulation_sizes.png){.absolute top=75 left=50 width="400"}

:::


::: {.fragment .fragment-index-3}

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

#### Scaling on multiple GPUs


![](assets/jax-1gpu.svg){.absolute top=420 right=800 width="40%" height="40%"}
[Single GPU (80GB)]{.absolute top=500 right=160}

:::



---


### Distributed Fast Fourier Transform

➢  &emsp;only operation that requires communication is the FFT

<br/>
<br/>

:::{.fragment fragment-index=1}

#### Jaxdecomp

<p style="display: flex; align-items: center; position: absolute; top: 10px; left: 700px;">
  <img src="assets/github_logo.png" alt="GitHub Logo" style="width: 5%; margin-right: 10px;">
  <a href="https://github.com/DifferentiableUniverseInitiative/jaxDecomp">DifferentiableUniverseInitiative/jaxDecomp</a>
</p>


snippet

add animation of the decomposition

:::


:::{.fragment fragment-index=2}


add plots of scallig

:::

:::{.fragment fragment-index=3}


jaxDecomp is also provided as a standalone library

:::


---

### Distributed JaxPM Particle-Mesh simulations 


:::{.fragment fragment-index=1}

➢  &emsp;Built on top of jaxDecomp

:::

:::{.fragment fragment-index=2}

➢  &emsp;Supports diffirentiable multi-host (multi-node) simulations

:::

:::{.fragment fragment-index=3}


image of 4000 mparsec box

:::


---

### Benchmarks


---

### Conclusion

➢  &emsp;

---

### Animation WIP

Unique solutions : no, two particles crossing each other yoy can't tell which one is which


---

### Backup slides (Halo exchange)

image of with and without halo exchange