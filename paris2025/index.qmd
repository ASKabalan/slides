---
title: '<span style="color:#ffffff; font-size: largest;">JAXPM: A JAX-Based Framework for Scalable and Differentiable Particle Mesh Simulations</span>'

author: 
  - name: "<span style='color:#ffffff; font-size: larger;'>Wassim Kabalan</span>"
  - name : "<span style='color:#ffffff; font-size: Smaller;'>Alexandre Boucaud, Fran√ßois Lanusse</span>"
footer: "Bayesian Deep Learning Workshop , 2025"
format:
  revealjs:
    theme: [default, css/custom.scss]
    incremental: false   
    transition: slide
    background-transition: slide
    presentation-size: max-scale
    highlight-style: github
    slide-number: true
    template-partials:
      - css/title-slide.html
output: revealjs

title-slide-attributes:
  data-background-image: "assets/titles/bayes_title_1.png"
  data-background-size: fill
  data-background-opacity: "0.8"


logo1 : '
<div style="display: flex; justify-content: space-around; align-items: center; layout-valign="middle">
  <img src="assets/Logos/AstroDeep-2.png" style="width: 35%;"/>
  <img src="assets/Logos/APC.png" style="width: 20%;"/>
  <img src="assets/Logos/scipol.png" style="width: 35%;"/>
</div>
'
---

## Goals for This Presentation 

<br/>
<br/>
<br/>


:::{.solutionbox}

::::{.solutionbox-body style="font-size: 22px; border-radius: 10px; border: 2px solid #3b0a68;"}



- <span style="color:#1a237e; font-size: 26px;">**Understand Field-Level Inference in Cosmology**</span>
<br/>
<br/>
- <span style="color:#1a237e; font-size: 26px;">**Deep Dive into Particle Mesh Simulation**</span>
<br/>
<br/>
- <span style="color:#1a237e; font-size: 26px;">**Weak Lensing and Lightcone Modeling**</span>
<br/>
<br/>
- <span style="color:#1a237e; font-size: 26px;">**Sampling with MCMC**</span>
<br/>
<br/>
- <span style="color:#1a237e; font-size: 26px;">**Explore Distributed, Differentiable N-body Simulations**</span>
<br/>
<br/>
- <span style="color:#1a237e; font-size: 26px;">**Connect Distributed Simulation and Inference**</span>


::::

:::



# Background :  Inference in Cosmology: The Big Picture 

---

## Inference in Cosmology: The Frequentist Pipeline {style="font-size: 20px;"}


:::{.columns}

:::: {.column width="55%"}

<br/>


:::::: {.fragment fragment-index=1 .fade-in}

![](assets/bayes/freq_pipeline_4.svg){fig-align="center" width="100%"}

::::::



::::

:::: {.column width="45%"}


:::::: {.fragment fragment-index=2 .fade-in}
- **cosmological parameters** (Œ©): matter density, dark energy, etc.
- Predict observables: **CMB, galaxies, lensing**
- Extract **summary statistics**: $P(k)$, $C_\ell$ , 2PCF
- Compute **likelihood**: $L(\Omega \vert data)$
- Estimate $\hat{\Omega}$ via **maximization** ($\chi^2$ fitting)
::::::


:::::: {.fragment fragment-index=3 .fade-in}

:::{.solutionbox}

::: {.solutionbox-header style="font-size: 19px;"}

**Limits of Summary Statistics**

:::

::::{.solutionbox-body style="font-size: 18px;"}

- Summary statistics are **lossy**  
- The power spectrum captures only **Gaussian** information  
- Higher-order statistics (e.g. bispectrum, peak counts):  
  ‚§∑ *difficult to model and interpret*  
  ‚§∑ *computationally expensive*  
  ‚§∑ *sensitive to systematics*  
- In the **nonlinear regime**, these issues worsen  

::::

:::

:::::: 

::::

:::


:::{.notes}

:::


---

## From Summary Statistics to Full Field Inference {style="font-size: 20px;"}

:::: {.columns}

:::: {.column width="60%"}


<br/>
<br/>


::::: {.r-stack}

:::::: {.fragment fragment-index=1 .fade-in-then-out}
![](assets/FFI/implicit_inference.svg){fig-align="center" width="100%"}
::::::

:::::: {.fragment fragment-index=2 .fade-in}
:::::: {.fragment fragment-index=4 .fade-out}
![](assets/bayes/FFI_full.svg){fig-align="center" width="100%"}
::::::
::::::

:::::: {.fragment fragment-index=4 .fade-in}
![](assets/FFI/FFI_nbody_focus.svg){fig-align="center" width="100%"}
::::::

:::::

::::

:::: {.column width="40%"}

:::::: {.fragment fragment-index=1 .fade-in}

### üîí Implicit (Likelihood-Free) Inference

- Simulator is a **blackbox**  
- No tractable likelihood  
- Only sample from the joint distribution
- Example : **Simulation-based inference (SBI)**

::::::

<br/>
<br/>

:::::: {.fragment fragment-index=2 .fade-in}

### üîç Explicit (Full-Field) Inference

- **Full-field forward model** is differentiable and structured  
- Likelihood defined in pixel space  
- Jointly infer cosmology + latent fields  
- Captures **all available information**
- Example : **Hierarchical Bayesian Modeling (HBM)**
::::::

::::

:::

:::::: {.fragment fragment-index=3 .fade-in}

:::{.solutionbox}

::: {.solutionbox-header style="font-size: 20px;"}
**Takeaway**
:::

:::: {.solutionbox-body style="font-size: 18px;"}
To unlock the full information in cosmological data,  
we must move from summary-based inference ‚Üí to structured, gradient-based field-level inference.
::::

:::

::::::


---

## Particle Mesh Simulations {style="font-size: 20px;"}

::: {.columns}

:::: {.column width="45%"}


::::: {.fragment fragment-index=1 .fade-in}
![](assets/latest/PM_forces.svg){fig-align="center" width="100%"}
:::::

::::: {.fragment fragment-index=2.fade-in}
![](assets/latest/PM_interpolate.svg){fig-align="center" width="100%"}
:::::


::::

:::: {.column width="55%"}

::::: {.fragment fragment-index=1 .fade-in}


###  Compute Forces via PM method

- **Start with particles** $\mathbf{x}_i, \mathbf{p}_i$  
- Interpolate to mesh: $\rho(\mathbf{x})$  
- Solve Poisson‚Äôs Equation:
  $$
  \nabla^2 \phi = -4\pi G \rho
  $$
- In Fourier space:
  $$
  \mathbf{f}(\mathbf{k}) = i\mathbf{k}k^{-2}\rho(\mathbf{k})
  $$

:::::

<br/>

::::: {.fragment fragment-index=2 .fade-in}

###  Time Evolution via ODE

- PM uses **Kick-Drift-Kick** (symplectic) scheme:
  - Drift: $\mathbf{x} \leftarrow \mathbf{x} + \Delta a \cdot \mathbf{v}$
  - Kick:  $\mathbf{v} \leftarrow \mathbf{v} + \Delta a \cdot \nabla \phi$
- Treated as a **differentiable ODE system** in JAXPM

:::::



::::

:::

::::: {.fragment fragment-index=3 .fade-in}

:::{.solutionbox}

:::: {.solutionbox-body style="font-size: 18px;"}
 - Fast and scalable approximation to gravity.
 - A cycle of FFTs and interpolations.
 - Sacrifices small-scale accuracy for speed and differentiability.
::::

:::

:::::

---

## Explicit Full-Field Inference (Weak Lensing)

::: {.r-stack}

::::: {.fragment fragment-index=1 .fade-in-then-out}
![](assets/bayes/FFI_full.svg){fig-align="center" width="100%"}
:::::
::::: {.fragment fragment-index=2 .fade-in}
![](assets/FFI/FFI_wl_focus.svg){fig-align="center" width="100%"}
:::::

:::


# Modeling Weak Lensing with Lightcone Projections


TODO

- Make Memory plots
- Make accuracy plots
- remaining slides 
- Make biased Omega and Sigma8


---

## Lightcone Model: From 3D Structure to Lensing Observables {style="font-size: 19px;"}


:::: {.columns}
:::: {.column width="60%"}

::::: {.r-stack}

:::::: {.fragment fragment-index=1 .fade-in-then-out}
![](assets/latest/how_converge.svg){fig-align="center" width="100%"}
::::::

:::::: {.fragment fragment-index=2 .fade-in-then-out}
![](assets/latest/lightcone_0.svg){fig-align="center" width="100%"}
::::::

:::::: {.fragment fragment-index=3 .fade-in-then-out}
![](assets/latest/lightcone_1.svg){fig-align="center" width="100%"}
::::::

:::::: {.fragment fragment-index=4 .fade-in-then-out}
![](assets/latest/lightcone_2.svg){fig-align="center" width="100%"}
::::::

:::::: {.fragment fragment-index=5 .fade-in-then-out}
![](assets/latest/lightcone_3.svg){fig-align="center" width="100%"}
::::::

:::::

::::

:::: {.column width="40%"}

:::::: {.fragment fragment-index=2 .fade-in}
- We simulate the large-scale structure  
  forward in time and take snapshots at scale factor $a_i$
::::::

:::::: {.fragment fragment-index=3 .fade-in}
- A lightcone connects these simulations  
  to an observer at $a = 1$
::::::

:::::: {.fragment fragment-index=3 .fade-in}
- We slice the volume into 2D mass planes  
  across comoving distance bins
::::::

:::::: {.fragment fragment-index=4 .fade-in}
- Each redshift bin receives contributions  
  from the slabs in front of it
- Born approximation 
::::::



:::::: {.fragment fragment-index=5 .fade-in}

:::{.solutionbox}

::: {.solutionbox-header}
Born Approximation for Convergence
:::

:::: {.solutionbox-body style="font-size: 18px;"}

$$
\kappa(\boldsymbol{\theta}) = \int_0^{r_s} dr \, W(r, r_s) \, \delta(\boldsymbol{\theta}, r)
$$

Where the lensing weight is:

$$
W(r, r_s) = \frac{3}{2} \, \Omega_m \, \left( \frac{H_0}{c} \right)^2 \, \frac{r}{a(r)} \left(1 - \frac{r}{r_s} \right)
$$

::::

:::

::::::

::::

:::

::::

:::




---

## Explicit Full-Field Inference (sampling)

::: {.r-stack}

::::: {.fragment fragment-index=1 .fade-in-then-out}
![](assets/bayes/FFI_full.svg){fig-align="center" width="100%"}
:::::
::::: {.fragment fragment-index=2 .fade-in}
![](assets/FFI/FFI_sample_focus.svg){fig-align="center" width="100%"}
:::::

:::


---

## Distributed Fast Fourier Transform {auto-animate="true"}

‚û¢  &emsp;only operation that requires communication is the FFT

<br/>

#### Jaxdecomp

:::: {.columns}

::: {.column width="50%"}

```python
import jax
import jax.numpy as jnp

field = jax.random.normal(jax.random.PRNGKey(0), (1024, 1024, 1024))
k_field = jnp.fft.fftn(field)
```

:::

::: {.column width="50%"}

:::

::::

:::{.notes}

L'op√©ration qui n√©cessite le plus de communication dans une simulation distribu√©e est la transform√©e de Fourier rapide (FFT).

L'utilisation sur un seul GPU est triviale

:::

---

## Distributed Fast Fourier Transform {auto-animate="true"}

‚û¢  &emsp;only operation that requires communication is the FFT

<br/>

#### Jaxdecomp

<p style="display: flex; align-items: center; position: absolute; top: 10px; left: 600px;">
  <img src="assets/Logos/github_logo.png" alt="GitHub Logo" style="width: 5%; margin-right: 10px;">
  <a href="https://github.com/DifferentiableUniverseInitiative/jaxDecomp">DifferentiableUniverseInitiative/jaxDecomp</a>
</p>

:::: {.columns}

::: {.column width="50%"}


::: {.r-stack}

```python
import jax
import jax.numpy as jnp
import jaxdecomp

mesh = jax.make_mesh((2, 2), axis_names=('x', 'y'))
sharding = jax.sharding.NamedSharding(mesh, P('x', 'y'))

# Create gaussian field distributed across the mesh
field = jax.make_array_from_single_device_arrays(
        shape=mesh_shape,
        sharding=sharding,
        arrays=[jax.random.normal(jax.random.PRNGKey(rank), (512, 512, 1024))])

k_field = jaxdecomp.fft.pfft3d(field)
```


:::

:::{.fragment fragment-index=1}


:::{.solutionbox}

::::{.solutionbox-header}

JaxDecomp features

::::

::::{.solutionbox-body}

‚û¢  &emsp;jaxDecomp supports 2D and 1D decompositions

‚û¢  &emsp;Works for multi-node FFTs

‚û¢  &emsp;is differentiable

‚û¢  &emsp;The package is also provided as a standalone library


::::

:::

:::

:::

::: {.column width="50%"}

:::{.fragment fragment-index=2}

![](assets/Fields/CIC/FFT-Op.svg){.nostretch fig-align="center" width="100%"}

:::

::: 

::::


