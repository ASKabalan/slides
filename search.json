[
  {
    "objectID": "csi2024/index.html#accelerating-bayesian-inference-in-cosmology",
    "href": "csi2024/index.html#accelerating-bayesian-inference-in-cosmology",
    "title": "CSI Presentation 2024",
    "section": "Accelerating Bayesian Inference in Cosmology",
    "text": "Accelerating Bayesian Inference in Cosmology\n \nWorking Framework\n➢   Using advanced software and tools to constrain cosmological parameters through Bayesian inference\n➢   Leveraging the Cosmic Microwave Background (CMB) as a tracer to constrain the tensor-to-scalar ratio, \\(r\\)\n➢   Utilizing weak lensing to constrain key cosmological parameters like \\(\\Omega_m\\) and \\(\\sigma_8\\)\n \n\n\nEmploying Cutting-Edge Tools\n➢   Transitioning from CPU-based NumPy to GPU-accelerated JAX for faster computation\n➢   Writing optimized CUDA code for cosmology-specific tools\n➢   Scaling cosmological simulations to run on multiple GPUs and HPC nodes for enhanced performance\n\n\nLe titre de ma thèse est « Accélérer les pipelines bayésiens pour la cosmologie ». Ce travail vise à accélérer les processus de calcul pour extraire les paramètres cosmologiques à l’aide de l’inférence bayésienne.\nL’inférence bayésienne, en utilisant le Fond diffus cosmologique (CMB) comme principal traceur, nous aide à contraindre des paramètres importants comme le rapport tenseur-surface \\(r\\), fournissant des informations sur l’inflation et les conditions de l’univers primitif.\nÀ mesure que l’univers évolue et que des structures à grande échelle se forment, nous utilisons le lentillage gravitationnel faible pour étudier ces structures et contraindre des paramètres comme \\(\\Omega_m\\) et \\(\\sigma_8\\).\nNEXT\nSur le plan technique, nous passons des calculs basés sur le CPU à des workflows accélérés par GPU en utilisant JAX, ce qui améliore considérablement la vitesse de nos simulations.\nNous optimisons également les outils cosmologiques avec CUDA et mettons à l’échelle nos simulations pour les exécuter sur plusieurs GPU et nœuds de clusters de calcul haute performance (HPC) afin de traiter efficacement de grandes quantités de données."
  },
  {
    "objectID": "csi2024/index.html#summary-of-projects",
    "href": "csi2024/index.html#summary-of-projects",
    "title": "CSI Presentation 2024",
    "section": "Summary of projects",
    "text": "Summary of projects\n\n\n\n\n\nProjects\n\n\n\n\nMon sujet de recherche est à cheval entre deux domaines : la séparation des composants du CMB dans le cadre du projet SciPol, et le lentillage gravitationnel faible avec AstroDeep. Je vais vous présenter ces deux projets plus en détail dans les prochaines diapositives."
  },
  {
    "objectID": "csi2024/index.html#cosmic-microwave-background---scipol",
    "href": "csi2024/index.html#cosmic-microwave-background---scipol",
    "title": "CSI Presentation 2024",
    "section": "Cosmic Microwave Background - Scipol",
    "text": "Cosmic Microwave Background - Scipol\n\n\n\n\n\nProjects\n\n\n\n\nOn commence par la separation de composants pour le fond diffus cosmologique"
  },
  {
    "objectID": "csi2024/index.html#cosmic-microwave-background",
    "href": "csi2024/index.html#cosmic-microwave-background",
    "title": "CSI Presentation 2024",
    "section": "Cosmic Microwave Background",
    "text": "Cosmic Microwave Background\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Cosmic Microwave Background (CMB) is the afterglow of the Big Bang, providing a snapshot of the early universe.\n\n\n\nThe CMB is polarized, consisting of E and B modes.\nE modes are curl-free, generated by density fluctuations.\nB modes could be evidence of primordial gravitational waves, indicating cosmic inflation.\nThe tensor-to-scalar ratio \\(r\\), which is the ratio of the tensor power spectrum to the scalar power spectrum\n\n\n\n\n\nLe fond diffus cosmologique, ou CMB, est le rayonnement fossile du Big Bang, qui nous offre une image de l’univers primitif.\nLe CMB est polarisé et se compose de deux types de modes : les E modes et les B modes.\nLes E modes ont un champ rotationnel nul et sont générés par les fluctuations de densité dans l’univers. En revanche, les B modes, qui possèdent un champ rotationnel, pourraient indiquer la présence d’ondes gravitationnelles primordiales.\nUn paramètre clé lié à ces B modes est le rapport tensor-surface \\(r\\), qui mesure la force relative des ondes gravitationnelles par rapport aux perturbations de densité, ce qui nous aide à mieux comprendre l’inflation cosmique."
  },
  {
    "objectID": "csi2024/index.html#cosmic-microwave-background-1",
    "href": "csi2024/index.html#cosmic-microwave-background-1",
    "title": "CSI Presentation 2024",
    "section": "Cosmic Microwave Background",
    "text": "Cosmic Microwave Background\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Cosmic Microwave Background (CMB) signal is obscured by various foregrounds, making it challenging to detect the true cosmological information.\n\n\n\nDust: Emission from galactic dust adds significant noise to the CMB, particularly affecting polarization measurements.\n\n\n\n\nSynchrotron Radiation: Electrons spiraling in the galaxy’s magnetic fields produce synchrotron radiation, another major contaminant.\n\n\n \n\n\nComponent seperation methods\n\nBlind Methods: Like SMICA (Spectral Matching Independent Component Analysis)\nParametric Methods: Like FGbuster (Foreground Buster)\n\n\n \n\n\n\nLe signal du fond diffus cosmologique, ou CMB, est en réalité obscurci par plusieurs avant-plans, ce qui rend difficile l’extraction des informations cosmologiques réelles.\nL’un des contaminants principaux est la poussière galactique. Cette poussière émet du rayonnement qui ajoute un bruit significatif au CMB, affectant particulièrement les mesures de polarisation.\nNEXT\nUn autre contaminant majeur est la radiation synchrotron. Elle est produite par des électrons en spirale dans les champs magnétiques de notre galaxie, ce qui vient encore plus brouiller le signal cosmologique que l’on souhaite observer.\nAFTER\nPour pouvoir extraire une valeur fiable du rapport \\(r\\), il est crucial de séparer ou de “démixer” ces composants. Le signal du CMB est mêlé à diverses émissions parasites.\nIl existe différentes méthodes pour cela, principalement des méthodes aveugles comme SMICA, qui fonctionnent sans connaissances préalables des avant-plans, et des méthodes paramétriques comme FGbuster, qui reposent sur la modélisation explicite des avant-plans.\nDans cette présentation, nous allons nous concentrer sur les méthodes paramétriques. Celles-ci nous permettent d’utiliser des modèles pour les avant-plans et d’améliorer la précision du processus de séparation."
  },
  {
    "objectID": "csi2024/index.html#cmb-component-separation",
    "href": "csi2024/index.html#cmb-component-separation",
    "title": "CSI Presentation 2024",
    "section": "CMB Component Separation",
    "text": "CMB Component Separation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModified Blackbody SED of Dust:\n\\[\n\\boxed{s_{\\mathrm{d}}(\\nu) = A_{\\mathrm{d}} \\cdot \\frac{\\nu}{\\exp\\left(\\frac{h\\nu}{k \\color{red}{T_{\\mathrm{d}}}}\\right) - 1} \\cdot \\frac{\\exp\\left(\\frac{h\\nu_{0}}{k \\color{red}{T_{\\mathrm{d}}}}\\right) - 1}{\\nu_{0}} \\cdot \\left(\\frac{\\nu}{\\nu_{0}}\\right)^{\\color{blue}{\\beta}}}\n\\]\n\n\nPower Law of Synchrotron Emission:\n\\[\n\\boxed{s_{\\text{synch}}(\\nu) = \\left(\\frac{\\nu}{\\nu_0}\\right)^{\\color{green}{\\beta_{\\text{pl}}}}}\n\\]\n\n\n\n\n\nSignal Representation\n\n\n\\[\n\\boxed{\\mathbf{d} = \\mathbf{A} \\mathbf{s} + \\mathbf{n}}\n\\]\n\n\\[\n\\boxed{\\mathbf{d} = \\color{green}{A_{\\text{synch}}} \\cdot s_{\\text{synch}} + \\color{blue}{A_{\\mathrm{d}}} \\cdot s_{\\mathrm{d}} + A_{\\text{cmb}} \\cdot s_{\\text{cmb}} + \\mathbf{n}}\n\\]\n\n\n\n\n\nLikelihood Function\n\\[\n\\boxed{-2 \\ln \\mathcal{L}_{\\text{data}}(\\mathbf{s}, \\boldsymbol{\\beta}) = \\text{const} + \\sum_{p} \\left( \\mathbf{d}_p - \\mathbf{A}_p \\mathbf{s}_p \\right)^T \\mathbf{N}_p^{-1} \\left( \\mathbf{d}_p - \\mathbf{A}_p \\mathbf{s}_p \\right)}\n\\]\n\n\n\n\nMinimization for Component Separation\n\\[\n\\boxed{\\mathbf{s} = \\left( \\mathbf{A}^T \\mathbf{N}^{-1} \\mathbf{d} \\right)^T \\left( \\mathbf{A}^T \\mathbf{N}^{-1} \\mathbf{A} \\right)^{-1} \\mathbf{A}^T \\mathbf{N}^{-1} \\mathbf{d}}\n\\]\n\n\n\nMinimization for Component Separation\n\\[\n\\boxed{\\mathcal{L}(\\color{blue}{\\beta_d}, \\color{red}{T_d}, \\color{green}{\\beta_{\\text{pl}}}) = \\left( \\mathbf{A}^T \\mathbf{N}^{-1} \\mathbf{d} \\right)^T  \\left( \\mathbf{A}^T \\mathbf{N}^{-1} \\mathbf{A} \\right)^{-1} \\mathbf{A}^T \\mathbf{N}^{-1} \\mathbf{d}}\n\\]\n\n\n\nDans cette diapositive, je vais expliquer comment on modélise la séparation des composantes du CMB à partir des données observées.\nNous avons d’abord deux composantes principales qui contaminent le signal CMB pur : - La poussière galactique, modélisée par une loi de corps noir modifiée. Elle est une des sources d’émission la plus importante à haute fréquence. - Le rayonnement synchrotron, produit par les électrons en spirale dans les champs magnétiques de la galaxie, qui est une source dominante à basse fréquence.\nOn représente ensuite le signal d par une combinaison linéaire des contributions de chaque composant multipliées par leur matrice de mélange respective, plus un bruit n.\nL’objectif de la séparation des composantes est de maximiser la vraisemblance de nos données modélisées par rapport aux données observées. Cela se fait par une minimisation, représentée par l’équation en bas de la diapositive.\nLa méthode que nous utilisons ici est paramétrique, où chaque composante a un modèle physique avec des paramètres spécifiques comme \\(\\beta\\), \\(T_d\\) pour la poussière et \\(\\beta_{pl}\\) pour le synchrotron.\nÀ la fin, nous obtenons la partie CMB de la matrice de mélange, à partir de laquelle nous allons pouvoir estimer le ratio tenseur-spectral \\(r\\), un paramètre clé pour contraindre les modèles d’inflation cosmique."
  },
  {
    "objectID": "csi2024/index.html#minimization-process-in-cmb-component-separation",
    "href": "csi2024/index.html#minimization-process-in-cmb-component-separation",
    "title": "CSI Presentation 2024",
    "section": "Minimization Process in CMB Component Separation",
    "text": "Minimization Process in CMB Component Separation\nUsing Scipols’s Furax Library (Chanial et al. in prep.)\n \nblocks = jnp.arange(24).reshape(3, 2, 4)\np = DenseBlockDiagonalOperator(blocks, jax.ShapeDtypeStruct((3, 4), jnp.int32), 'imn,in-&gt;im')\nop.as_matrix()\nArray([[ 0,  1,  2,  3,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 4,  5,  6,  7,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0,  0,  0,  8,  9, 10, 11,  0,  0,  0,  0],\n       [ 0,  0,  0,  0, 12, 13, 14, 15,  0,  0,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0, 16, 17, 18, 19],\n       [ 0,  0,  0,  0,  0,  0,  0,  0, 20, 21, 22, 23]], dtype=int32)\n \n\n\n\nMy contributions\n\n\n\nUse JAX tools to evaluate the spectral likelihood.\nApply gradient descent methods to minimize the likelihood function.\n\nImplement support for multi-patch analysis.\n\n\n\n\n\n\nCette matrice bloc-diagonale que nous utilisons pour la séparation des composantes du CMB a une taille de l’ordre de (fréquence, stokes, composante, npix), et peut rapidement atteindre plusieurs gigaoctets en mémoire. Avec des résolutions élevées et de multiples fréquences, la gestion efficace de cette matrice devient critique. C’est pourquoi l’utilisation d’outils comme JAX est indispensable pour optimiser les calculs, en exploitant l’accélération par GPU tout en minimisant la consommation de mémoire et les temps de calcul.\nMon travail consiste à utiliser les outils de JAX pour évaluer la fonction de vraisemblance spectrale, puis appliquer des méthodes de descente de gradient pour minimiser cette fonction et optimiser la séparation des composantes du CMB.\nÀ l’avenir, je prévois d’adapter ce code pour gérer des données multi-résolution et permettre une analyse multi-patch, afin de traiter plus efficacement des régions distinctes du ciel avec des résolutions variées."
  },
  {
    "objectID": "csi2024/index.html#summary-of-projects-1",
    "href": "csi2024/index.html#summary-of-projects-1",
    "title": "CSI Presentation 2024",
    "section": "Summary of projects",
    "text": "Summary of projects\n\n\n\n\nProjects"
  },
  {
    "objectID": "csi2024/index.html#weak-lensing---astrodeepaim",
    "href": "csi2024/index.html#weak-lensing---astrodeepaim",
    "title": "CSI Presentation 2024",
    "section": "Weak Lensing - AstroDeep/Aim",
    "text": "Weak Lensing - AstroDeep/Aim\n\n\n\n\nProjects"
  },
  {
    "objectID": "csi2024/index.html#weak-lensing---statistical-tools",
    "href": "csi2024/index.html#weak-lensing---statistical-tools",
    "title": "CSI Presentation 2024",
    "section": "Weak Lensing - Statistical Tools",
    "text": "Weak Lensing - Statistical Tools\n\n\n\n\n\n\n\nHubble eXtreme Deep Field\n\n\n\n\n\n\n\nHubble eXtreme Deep Field\n\n\n\n\n\\[\n-2 \\underbrace{\\log P(g, \\boldsymbol{\\beta} \\mid \\mathbf{d})}_{\\text{Posterior}} =\n\\sum_{\\vec{k}} \\left[\\underbrace{\\frac{\\left|\\mathbf{d} - f(g \\mid \\boldsymbol{\\beta}, z)\\right|^2}{N}}_{\\text{Likelihood}} + \\underbrace{\\frac{|g|^2}{\\mathcal{P}(\\boldsymbol{\\beta})}}_{\\text{Prior}}\\right]_{\\vec{k}}\n\\]\n\n\n\n\n\n\nPrediction\n\n\n\n\n\n\n\n\n\n\n\n\n\nGaussian field\n\n\n\n\n \n\n\n\n\n\nLPT Field\n\n\n\n\n \n\n\n\n\n\nGalaxies\n\n\n\n\n\n\n\n\n\nInference"
  },
  {
    "objectID": "csi2024/index.html#hearchical-bayesian-modeling",
    "href": "csi2024/index.html#hearchical-bayesian-modeling",
    "title": "CSI Presentation 2024",
    "section": "Hearchical Bayesian Modeling",
    "text": "Hearchical Bayesian Modeling\n\n\n\n\n\nProbabilistic Graphical Model\n\n\n\n➕  No longer need to compute the likelihood analytically   ➖  We need to infer the joint posterior \\(p(\\beta, g | z)\\) before marginalization to get \\(p(\\beta | g) = \\int p(\\beta, z | g) \\, dz\\)\n\n\n\n\n\nPossible solutions\n\n\n\nHamiltonian Monte Carlo\nVariational Inference\nDimensionality reduction using Fisher Information Matrix\n\nAll require a differentiable fast forward model"
  },
  {
    "objectID": "csi2024/index.html#fast-particle-mesh-simulations",
    "href": "csi2024/index.html#fast-particle-mesh-simulations",
    "title": "CSI Presentation 2024",
    "section": "Fast Particle-mesh simulations",
    "text": "Fast Particle-mesh simulations\n \n\n\nNumerical scheme\n\n➢  Interpolate particles on a grid to estimate mass density\n\n\n➢  Estimate gravitational force on grid points by FFT\n\n\n➢  Interpolate forces back on particles\n\n\n➢  Update particle velocity and positions, and iterate\n\n\n\n\n\n\n\n\n\\(\\begin{array}{c}{{\\nabla^{2}\\phi=-4\\pi G\\rho}}\\\\\\\\ {{f(\\vec{k})=i\\vec{k}k^{-2}\\rho(\\vec{k})}}\\end{array}\\)\n\n\n\n\n\n\n\n\n     \n\n\n\nFast and simple, at the cost of approximating short range interactions.\nIt is essentially a series of FFTs and interpolations\nIt is differentiable and can run on GPUs"
  },
  {
    "objectID": "csi2024/index.html#jaxpm-a-differentiable-particle-mesh-simulation",
    "href": "csi2024/index.html#jaxpm-a-differentiable-particle-mesh-simulation",
    "title": "CSI Presentation 2024",
    "section": "JaxPM : A differentiable Particle-Mesh simulation",
    "text": "JaxPM : A differentiable Particle-Mesh simulation\nFastPM simulation in a few lines of code\n\n\n\n\n\n\n\n\nmesh_shape = [64, 64, 64]\nbox_size = [64., 64., 64.]\nsnapshots = jnp.linspace(0.1, 1., 2)\n\n@jax.jit\ndef run_simulation(omega_c, sigma8):\n    # Create a small function to generate the matter power spectrum\n    k = jnp.logspace(-4, 1, 128)\n    pk = jc.power.linear_matter_power(\n        jc.Planck15(Omega_c=omega_c, sigma8=sigma8), k)\n    pk_fn = lambda x: jc.scipy.interpolate.interp(x.reshape([-1]), k, pk\n                                                  ).reshape(x.shape)\n\n    # Create initial conditions\n    initial_conditions = linear_field(mesh_shape,\n                                      box_size,\n                                      pk_fn,\n                                      seed=jax.random.PRNGKey(0))\n\n    # Create particles\n    particles = jnp.stack(jnp.meshgrid(*[jnp.arange(s) for s in mesh_shape]),\n                          axis=-1).reshape([-1, 3])\n\n    cosmo = jc.Planck15(Omega_c=omega_c, sigma8=sigma8)\n\n    # Initial displacement\n    dx, p, f = lpt(cosmo, initial_conditions, particles, 0.1)\n    field = dx + particles\n\n    # Evolve the simulation forward\n    ode_fn = make_ode_fn(mesh_shape)\n    term = ODETerm(lambda t, state, args: jnp.stack(ode_fn(state, t, args), axis=0))\n    solver = Dopri5()\n\n    stepsize_controller = PIDController(rtol=1e-7, atol=1e-7)\n    res = diffeqsolve(term, solver, t0=0.1, t1=1., dt0=0.01, y0=jnp.stack([dx, p],axis=0), \n                       args=(cosmo , kvec),\n                       stepsize_controller=stepsize_controller,\n                       saveat=SaveAt(ts=snapshots))\n\n    # Return the simulation volume at requested\n    return field, res, initial_conditions\n\nfield, res, initial_conditions = run_simulation(0.25, 0.8)"
  },
  {
    "objectID": "csi2024/index.html#fast-particle-mesh-scaling",
    "href": "csi2024/index.html#fast-particle-mesh-scaling",
    "title": "CSI Presentation 2024",
    "section": "Fast Particle-mesh scaling",
    "text": "Fast Particle-mesh scaling\n➢  (Poqueres et al. 2021) : \\(64^3\\) mesh size, on a 1000 Mpc/h box\n➢  (Li et al. 2022) : \\(512^3\\) mesh size, using pmwd\n\n\n\n\n\n\n\n\n\n\nInitial Conditions with a 1024 mesh\n\n\n\n\n\n\n\nInitial Conditions with a 64 mesh\n\n\n\n\n\n\n\nPower spectrum comparison\n\n\n\n\n\n\n\n\n\n\nFinal field with a 1024 mesh\n\n\n\n\n\n\n\nFinal field with a 64 mesh\n\n\n\n\n\n\n\n\n\nScaling\n\n\nWe need a fast, differentiable and Scalable Particle-Mesh simulation"
  },
  {
    "objectID": "csi2024/index.html#scaling-on-modern-hardware",
    "href": "csi2024/index.html#scaling-on-modern-hardware",
    "title": "CSI Presentation 2024",
    "section": "Scaling on modern hardware",
    "text": "Scaling on modern hardware\nSize of a FastPM simulation\n\n\n\n\n\n\n\nScaling on multiple GPUs\n\n\n\n\n\n\n\n\n\nSingle GPU (80GB)\n\n\n\n\n\n\n\nSingle Node (8x80GB)\n\n\n\n\n\n\n\nMuti Node ( \\(\\infty\\) )"
  },
  {
    "objectID": "csi2024/index.html#distributed-fast-fourier-transform",
    "href": "csi2024/index.html#distributed-fast-fourier-transform",
    "title": "CSI Presentation 2024",
    "section": "Distributed Fast Fourier Transform",
    "text": "Distributed Fast Fourier Transform\n➢  only operation that requires communication is the FFT\n\nJaxdecomp\n\n\nimport jax\nimport jax.numpy as jnp\n\nfield = jax.random.normal(jax.random.PRNGKey(0), (1024, 1024, 1024))\nk_field = jnp.fft.fftn(field)"
  },
  {
    "objectID": "csi2024/index.html#distributed-fast-fourier-transform-1",
    "href": "csi2024/index.html#distributed-fast-fourier-transform-1",
    "title": "CSI Presentation 2024",
    "section": "Distributed Fast Fourier Transform",
    "text": "Distributed Fast Fourier Transform\n➢  only operation that requires communication is the FFT\n\nJaxdecomp\n\n DifferentiableUniverseInitiative/jaxDecomp\n\n\n\n\nimport jax\nimport jax.numpy as jnp\nimport jaxdecomp\n\ndevices = mesh_utils.create_device_mesh((2, 2))\nmesh = jax.sharding.Mesh(devices, axis_names=('x', 'y'))\nsharding = jax.sharding.NamedSharding(mesh, P('x', 'y'))\n\n# Create gaussian field distributed across the mesh\nfield = jax.make_array_from_single_device_arrays(\n        shape=mesh_shape,\n        sharding=sharding,\n        arrays=[jax.random.normal(jax.random.PRNGKey(rank), (512, 512, 1024))])\n\nk_field = jaxdecomp.fft.pfft3d(field)\n\n\n\n\n\n\n\n\nJaxDecomp features\n\n\n➢  jaxDecomp supports 2D and 1D decompositions\n➢  Works for multi-node FFTs\n➢  is differentiable\n➢  The package is also provided as a standalone library"
  },
  {
    "objectID": "csi2024/index.html#scaling-of-distributed-fft-operations",
    "href": "csi2024/index.html#scaling-of-distributed-fft-operations",
    "title": "CSI Presentation 2024",
    "section": "Scaling of Distributed FFT operations",
    "text": "Scaling of Distributed FFT operations"
  },
  {
    "objectID": "csi2024/index.html#interpolation-function-for-particle-mesh-simulations",
    "href": "csi2024/index.html#interpolation-function-for-particle-mesh-simulations",
    "title": "CSI Presentation 2024",
    "section": "Interpolation function for Particle-Mesh simulations",
    "text": "Interpolation function for Particle-Mesh simulations\n\n\nCIC Paint Function:\n\\[\n\\begin{array}{l c r}\ng({\\bf j})=\\sum_{i=1}^{N}m_{i}\\times\\prod_{d=1}^{D}\\left(1-\\left|p_{i}^{d}-j_{d}\\right|\\right)\n\\end{array}\n\\]\nForces Functions:\n\\[\n\\nabla^{2}\\phi = -4\\pi G\\kappa\\rho\n\\]\n\\[\nf(\\vec{k}) = \\dot{\\vec{k}}k^{-2}\\rho(\\vec{k})\n\\]\nCIC Read Function:\n\\[\nv_{i} = \\sum_{{\\bf j}}g({\\bf j})\\times\\prod_{d=1}^{D}\\left(1-|p_{i}^{d}-j_{d}|\\right)\n\\]\n\n\n➢  Periodic boundary conditions\n➢  Not compatible with distributed simulations\n\n\n\n\n\n\nParticles\n\n\n\n\n\nCIC Kernel\n\n\n\n\n\nMesh\n\n\n\n\n\n\n\n\n\n\n\nGradients\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDisplacement"
  },
  {
    "objectID": "csi2024/index.html#halo-exchange-in-distributed-simulations",
    "href": "csi2024/index.html#halo-exchange-in-distributed-simulations",
    "title": "CSI Presentation 2024",
    "section": "Halo exchange in distributed simulations",
    "text": "Halo exchange in distributed simulations\n\n\n\n\n\n\n\n\n\n\n\nInitial Field\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst slice\n\n\n\n\n\n\n\n\n\nSecond slice\n\n\n\n\n\n\n\n\n\nThird slice\n\n\n\n\n\n\n\n\n\nFourth slice\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst slice\n\n\n\n\n\n\n\n\n\nSecond slice\n\n\n\n\n\n\n\n\n\nThird slice\n\n\n\n\n\n\n\n\n\nFourth slice\n\n\n\n\n\n\n\n\n\n\nLPT Field\n\n\n\n\n\n\n\nLPT Field\n\n\n\n\n\n\n\nCIC Kernel\n\n\n\n\n\n\n\nHalo Exchangel\n\n\n\n\n\n\nfrom jaxdecomp import halo_exchange\n\nhalo_size = 128\nfield = halo_exchange(field, halo_extent=halo_size)"
  },
  {
    "objectID": "csi2024/index.html#summary-of-projects-2",
    "href": "csi2024/index.html#summary-of-projects-2",
    "title": "CSI Presentation 2024",
    "section": "Summary of projects",
    "text": "Summary of projects\n\n\n\n\nProjects"
  },
  {
    "objectID": "csi2024/index.html#weak-lensing---astrodeepaim-1",
    "href": "csi2024/index.html#weak-lensing---astrodeepaim-1",
    "title": "CSI Presentation 2024",
    "section": "Weak Lensing - AstroDeep/Aim",
    "text": "Weak Lensing - AstroDeep/Aim\n\n\n\n\nProjects"
  },
  {
    "objectID": "csi2024/index.html#attended-conferences-papers",
    "href": "csi2024/index.html#attended-conferences-papers",
    "title": "CSI Presentation 2024",
    "section": "Attended Conferences & Papers",
    "text": "Attended Conferences & Papers\nConferences\n\nIAP 2023 Machine Learning\nLSST France 2023 Lyon, France\nMoriond Cosmology 2023 La Thuile, Italy (Poster)\nLSST France 2024 Marseille, France (Talk)\nLSST DESC 2024 Zurich, Switzerland\n[Future] IAP GDR CoPhy Tools 2024 Paris, France (Presentation)\n\nPapers\n\nInfrared Radiometric Image Classification and Segmentation of Cloud Structure Using ML (Published)\nJaxDecomp: A Distributed Fast Fourier Transform Library (Draft being reviewed by supervisors)\nFurax : Optimization of the Large Scale Multiresolution Parametric Component Separation (In prep.)\nJaxPM: A Differentiable Particle-Mesh Simulation (In prep.)\n\nFuture papers\n\nSpherical Harmonics for CMB component separation\nDistributed Probabilistic Programming for Hierarchical Bayesian Modeling (FFI)\n\n\n\n\nCSI Presentation 2024"
  },
  {
    "objectID": "marseille2024/index.html#traditional-cosmological-inference",
    "href": "marseille2024/index.html#traditional-cosmological-inference",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "Traditional cosmological inference",
    "text": "Traditional cosmological inference\n\nBayesian inference in cosmology\n\nWe need to infer the cosmological parameters \\(\\theta\\) that generated an observartion \\(x\\)\n\n\\[p(\\theta | x ) \\propto \\underbrace{p(x | \\theta)}_{\\mathrm{likelihood}} \\ \\underbrace{p(\\theta)}_{\\mathrm{prior}}\\]\n\n\n\n\n\n\n\n\n\n\n ➢  Compute summary statistics based on the 2-point correlation function of the shear field\n\n\n ➢  Run an MCMC chain to recover the posterior distribution of the cosmological parameters, using an analytical likelihood\n\n\n\n\n\n\n\nLimitations\n\n\n\nSimple summary statistics assume Gaussianity\nThe need to compute an analytical likelihood"
  },
  {
    "objectID": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration",
    "href": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "JAX : Automatic differentiation and Hardware acceleration",
    "text": "JAX : Automatic differentiation and Hardware acceleration\n\n     \nimport numpy as np\n\n\ndef multiply_and_add(a, b, c):\n    return np.dot(a, b) + c\n\n\na, b, c = np.random.normal(size=(3, 32, 32))\nresult = multiply_and_add(a, b, c)\n\n\nimport jax\nimport jax.numpy as jnp\n\n\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c)"
  },
  {
    "objectID": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration-1",
    "href": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration-1",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "JAX : Automatic differentiation and Hardware acceleration",
    "text": "JAX : Automatic differentiation and Hardware acceleration\n\n     \nimport jax\nimport jax.numpy as jnp\n\n\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c)"
  },
  {
    "objectID": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration-2",
    "href": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration-2",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "JAX : Automatic differentiation and Hardware acceleration",
    "text": "JAX : Automatic differentiation and Hardware acceleration\n\n     \nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c) \ngradient = jax.grad(multiply_and_add)(a, b, c)\n \n\n\nJAX : Numpy + Autograd + GPU\n\n\n\njax.grad uses automatic differentiation to compute the gradient of the function\njax.jit compiles the function to run on GPUs"
  },
  {
    "objectID": "marseille2024/index.html#distributed-fast-fourier-transform",
    "href": "marseille2024/index.html#distributed-fast-fourier-transform",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "Distributed Fast Fourier Transform",
    "text": "Distributed Fast Fourier Transform\n➢  only operation that requires communication is the FFT\n\nJaxdecomp\n\n\nimport jax\nimport jax.numpy as jnp\n\nfield = jax.random.normal(jax.random.PRNGKey(0), (1024, 1024, 1024))\nk_field = jnp.fft.fftn(field)"
  },
  {
    "objectID": "marseille2024/index.html#distributed-fast-fourier-transform-1",
    "href": "marseille2024/index.html#distributed-fast-fourier-transform-1",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "Distributed Fast Fourier Transform",
    "text": "Distributed Fast Fourier Transform\n➢  only operation that requires communication is the FFT\n\nJaxdecomp\n\n DifferentiableUniverseInitiative/jaxDecomp\n\n\n\nimport jax\nimport jax.numpy as jnp\nimport jaxdecomp\n\ndevices = mesh_utils.create_device_mesh((2, 2))\nmesh = jax.sharding.Mesh(devices, axis_names=('x', 'y'))\nsharding = jax.sharding.NamedSharding(mesh, P('x', 'y'))\n\n# Create gaussian field distributed across the mesh\nfield = jax.make_array_from_single_device_arrays(\n    shape=mesh_shape,\n    sharding=sharding,\n    arrays=[jax.random.normal(jax.random.PRNGKey(rank), (512, 512, 1024))])\n\nk_field = jaxdecomp.fft.pfft3d(field)\n\n\n\n\nJaxDecomp features\n\n\n➢  jaxDecomp supports 2D and 1D decompositions\n➢  Works for multi-node FFTs\n➢  is differentiable\n➢  The package is also provided as a standalone library"
  },
  {
    "objectID": "marseille2024/index.html#halo-exchange-in-distributed-simulations",
    "href": "marseille2024/index.html#halo-exchange-in-distributed-simulations",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "Halo exchange in distributed simulations",
    "text": "Halo exchange in distributed simulations\n\n\n\n\n\n\n\n\n\n\n\nInitial Field\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst slice\n\n\n\n\n\n\n\n\n\nSecond slice\n\n\n\n\n\n\n\n\n\nThird slice\n\n\n\n\n\n\n\n\n\nFourth slice\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst slice\n\n\n\n\n\n\n\n\n\nSecond slice\n\n\n\n\n\n\n\n\n\nThird slice\n\n\n\n\n\n\n\n\n\nFourth slice\n\n\n\n\n\n\n\n\n\n\nLPT Field\n\n\n\n\n\n\n\nLPT Field\n\n\n\n\n\n\nfrom jaxdecomp import halo_exchange\n\nhalo_size = 128\nfield = halo_exchange(field, halo_extent=halo_size)"
  },
  {
    "objectID": "marseille2024/index.html#conclusion",
    "href": "marseille2024/index.html#conclusion",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "Conclusion ",
    "text": "Conclusion \n   \n\n\nDistruibuted Particle-Mesh simulations for cosmological inference\n\n\n\nA shift from analytical likelihoods to full field inference\n\nThe need for fast differentiable simulators\nParticle-Mesh as simulators for full field inference\nDistributed fourrier transforms that work on multi-node HPC using jaxDecomp\nHighly scalable LPT simulations using JaxPM\n\nStill subject to some challenges\n\nSome issues with the ODE solving step\nOnly Euler gives decent results.\n\n\n\n\n\n\n\nLSST France, 2024"
  },
  {
    "objectID": "notes.html",
    "href": "notes.html",
    "title": "",
    "section": "",
    "text": "1 - contraint cosmo\nCadre de travail\n\nAjouter un cadre de travail\n\nAccelerating Bayesian pipelines for cosmology\nConstraining cosmological parameters\nR , Sigma 8 Omega m\nNumerical tools\nHardware acceleration Avant JAX the future Inversion de la matrice Exemple de la taille\n\ndonnes complex volumineux\nLa contrate mise sur R\nCMB as tracer\nSMICA blind methonds\nCadre de SO LiteBird\nScipols parametric method fgbuster [cite] Remove slide 7 ~fix liklehood~\n\nslide 8\nSolution box saying contribution instead of second part\nslide 9\nConclusion\nShift from CPU and pure numpy based computation to JAX Using a gradient based Minimisation TODO Expand to include the ability to do multi resolution and multi patch seperation\nPaper\nSlide 12\nswitch power spectrum image\ntalk : instead of using a summary statistique we use the entire field (data) we have at hand\nSlide 13\ncite Remove HMC To slow to be usable\nSlide 14\nChange the gif to have black dots\nSLide 15\nLess code\nCite Francois\nBetter graphics\nadd constribution\nSlide 16\nExplain Small scale lower resolution the less acurate is the simulation for the small scale interaction\nSlide 17\nAdd units for the plots Stress the Fact that we are the only one doing this\nSlide 18\nSwitch animagion with depiction\nShow image of field\nSkide 19\nSlide 21\nCIC explain\nAdd Fragmentation\n~Pas de Matrices~\n~Corriger L(BETA…)~\nFurax ~Resumé constribution aprs chaque truc~\nQ quoi ça sert\nMulti res Muilti patch remove (prospectus Next steps)\nAstroDeep pas AIM\nPas de UCL\nBule JAX HPC etc ..\nFaire Age plus avance Evolution des structures\nR =&gt; Omega m Sigma 8\nResumé par le spectre de puissance\nMethodes de contraint\nSBI (faire des simulation rapidement)\n–&gt; Weak lensing shear field\nHMC pas besoin de le mettre Très lent sans Gradient\nPetite echelle et grande echelle –&gt;\nPour le SBI il faut faire beaucoup\nBottleneck les outils\nFaut expliquer LPT\nScale factor evolution\nTaille physique (en MP\nScaling on medern hardware\nNumero du slide\nScaling on modern hardware –&gt; remove\nMy contribution is …"
  }
]