[
  {
    "objectID": "csi2024/index.html#summary-of-projects",
    "href": "csi2024/index.html#summary-of-projects",
    "title": "CSI Presentation 2024",
    "section": "Summary of projects",
    "text": "Summary of projects\n\n\n\n\nProjects"
  },
  {
    "objectID": "csi2024/index.html#cosmic-microwave-background---scipol",
    "href": "csi2024/index.html#cosmic-microwave-background---scipol",
    "title": "CSI Presentation 2024",
    "section": "Cosmic Microwave Background - Scipol",
    "text": "Cosmic Microwave Background - Scipol\n\n\n\n\nProjects"
  },
  {
    "objectID": "csi2024/index.html#cosmic-microwave-background",
    "href": "csi2024/index.html#cosmic-microwave-background",
    "title": "CSI Presentation 2024",
    "section": "Cosmic Microwave Background",
    "text": "Cosmic Microwave Background\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Cosmic Microwave Background (CMB) is the afterglow of the Big Bang, providing a snapshot of the early universe.\n\n\n\nThe CMB is polarized, consisting of E and B modes.\nE modes are curl-free, generated by density fluctuations.\nB modes could be evidence of primordial gravitational waves, indicating cosmic inflation."
  },
  {
    "objectID": "csi2024/index.html#cosmic-microwave-background-1",
    "href": "csi2024/index.html#cosmic-microwave-background-1",
    "title": "CSI Presentation 2024",
    "section": "Cosmic Microwave Background",
    "text": "Cosmic Microwave Background\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe Cosmic Microwave Background (CMB) signal is obscured by various foregrounds, making it challenging to detect the true cosmological information.\n\n\n\nDust: Emission from galactic dust adds significant noise to the CMB, particularly affecting polarization measurements.\n\n\n\n\nSynchrotron Radiation: Electrons spiraling in the galaxy’s magnetic fields produce synchrotron radiation, another major contaminant."
  },
  {
    "objectID": "csi2024/index.html#cmb-component-separation",
    "href": "csi2024/index.html#cmb-component-separation",
    "title": "CSI Presentation 2024",
    "section": "CMB Component Separation",
    "text": "CMB Component Separation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nModified Blackbody SED of Dust:\n\\[\n\\boxed{s_{\\mathrm{d}}(\\nu) = A_{\\mathrm{d}} \\cdot \\frac{\\nu}{\\exp\\left(\\frac{h\\nu}{k \\color{red}{T_{\\mathrm{d}}}}\\right) - 1} \\cdot \\frac{\\exp\\left(\\frac{h\\nu_{0}}{k \\color{red}{T_{\\mathrm{d}}}}\\right) - 1}{\\nu_{0}} \\cdot \\left(\\frac{\\nu}{\\nu_{0}}\\right)^{\\color{blue}{\\beta}}}\n\\]\n\n\nPower Law of Synchrotron Emission:\n\\[\n\\boxed{s_{\\text{synch}}(\\nu) = \\left(\\frac{\\nu}{\\nu_0}\\right)^{\\color{green}{\\beta_{\\text{pl}}}}}\n\\]\n\n\n\n\n\nSignal Representation\n\n\n\\[\n\\boxed{\\mathbf{d} = \\mathbf{A} \\mathbf{s} + \\mathbf{n}}\n\\]\n\n\\[\n\\boxed{\\mathbf{d} = \\color{green}{A_{\\text{synch}}} \\cdot s_{\\text{synch}} + \\color{blue}{A_{\\mathrm{d}}} \\cdot s_{\\mathrm{d}} + A_{\\text{cmb}} \\cdot s_{\\text{cmb}} + \\mathbf{n}}\n\\]\n\n\n\n\n\nLikelihood Function\n\\[\n\\boxed{-2 \\ln \\mathcal{L}_{\\text{data}}(\\mathbf{s}, \\boldsymbol{\\beta}) = \\text{const} + \\sum_{p} \\left( \\mathbf{d}_p - \\mathbf{A}_p \\mathbf{s}_p \\right)^T \\mathbf{N}_p^{-1} \\left( \\mathbf{d}_p - \\mathbf{A}_p \\mathbf{s}_p \\right)}\n\\]\n\n\n\n\nMinimization for Component Separation\n\\[\n\\boxed{\\mathbf{s} = \\left( \\mathbf{A}^T \\mathbf{N}^{-1} \\mathbf{A} \\right)^{-1} \\mathbf{A}^T \\mathbf{N}^{-1} \\mathbf{d}}\n\\]\n\n\n\nMinimization for Component Separation\n\\[\n\\boxed{\\mathcal{L}(\\color{blue}{\\beta_d}, \\color{red}{T_d}, \\color{green}{\\beta_{\\text{pl}}}) = \\left( \\mathbf{A}^T \\mathbf{N}^{-1} \\mathbf{A} \\right)^{-1} \\mathbf{A}^T \\mathbf{N}^{-1} \\mathbf{d}}\n\\]"
  },
  {
    "objectID": "csi2024/index.html#structure-of-the-matrices-in-cmb-component-separation",
    "href": "csi2024/index.html#structure-of-the-matrices-in-cmb-component-separation",
    "title": "CSI Presentation 2024",
    "section": "Structure of the Matrices in CMB Component Separation",
    "text": "Structure of the Matrices in CMB Component Separation\n\n\nMixed Component Matrix:\n\\[\n\\mathbf{d} =\n\\left[\n\\begin{array}{c@{}c@{}c}\n\\left[\\begin{array}{ccc}\n         I_{0,0} & 0       & 0 \\\\\n         0       & Q_{0,0} & 0 \\\\\n         0       & 0       & U_{0,0} \\\\\n  \\end{array}\\right]\n  & \\cdots &  \n  \\left[\\begin{array}{ccc}\n         I_{0,p} & 0       & 0 \\\\\n         0       & Q_{0,p} & 0 \\\\\n         0       & 0       & U_{0,p} \\\\\n  \\end{array}\\right] \\\\\n  \\vdots & \\ddots & \\vdots \\\\\n  \\left[\\begin{array}{ccc}\n         I_{F,0} & 0       & 0 \\\\\n         0       & Q_{F,0} & 0 \\\\\n         0       & 0       & U_{F,0} \\\\\n  \\end{array}\\right]\n  & \\cdots &  \n  \\left[\\begin{array}{ccc}\n         I_{F,p} & 0       & 0 \\\\\n         0       & Q_{F,p} & 0 \\\\\n         0       & 0       & U_{F,p} \\\\\n  \\end{array}\\right] \\\\\n\\end{array}\n\\right]  \n\\]\n\n\nMixing Matrix:\n\\[\n\\mathbf{A}(\\beta) =\n\\left[\n\\begin{array}{c@{}c@{}c}\n\\left[\\begin{array}{ccc}\n         I_{0,0,0} & 0          & 0 \\\\\n         0         & Q_{0,0,0}  & 0 \\\\\n         0         & 0          & U_{0,0,0} \\\\\n  \\end{array}\\right]\n  & \\cdots &\n  \\left[\\begin{array}{ccc}\n         I_{0,0,c} & 0          & 0 \\\\\n         0         & Q_{0,0,c}  & 0 \\\\\n         0         & 0          & U_{0,0,c} \\\\\n  \\end{array}\\right]\n  & \\cdots &  \n  \\left[\\begin{array}{ccc}\n         I_{0,p,c} & 0          & 0 \\\\\n         0         & Q_{0,p,c}  & 0 \\\\\n         0         & 0          & U_{0,p,c} \\\\\n  \\end{array}\\right] \\\\\n  \\vdots & \\ddots & \\vdots & \\ddots & \\vdots \\\\\n  \\left[\\begin{array}{ccc}\n         I_{F,0,0} & 0          & 0 \\\\\n         0         & Q_{F,0,0}  & 0 \\\\\n         0         & 0          & U_{F,0,0} \\\\\n  \\end{array}\\right]\n  & \\cdots &\n  \\left[\\begin{array}{ccc}\n         I_{F,0,c} & 0          & 0 \\\\\n         0         & Q_{F,0,c}  & 0 \\\\\n         0         & 0          & U_{F,0,c} \\\\\n  \\end{array}\\right]\n  & \\cdots &  \n  \\left[\\begin{array}{ccc}\n         I_{F,p,c} & 0          & 0 \\\\\n         0         & Q_{F,p,c}  & 0 \\\\\n         0         & 0          & U_{F,p,c} \\\\\n  \\end{array}\\right] \\\\\n\\end{array}\n\\right]\n\\]"
  },
  {
    "objectID": "csi2024/index.html#minimization-process-in-cmb-component-separation",
    "href": "csi2024/index.html#minimization-process-in-cmb-component-separation",
    "title": "CSI Presentation 2024",
    "section": "Minimization Process in CMB Component Separation",
    "text": "Minimization Process in CMB Component Separation\nPart 1: Using Scipols’s Furax Library (Chanial et al. in prep.)\n \nblocks = jnp.arange(24).reshape(3, 2, 4)\np = DenseBlockDiagonalOperator(blocks, jax.ShapeDtypeStruct((3, 4), jnp.int32), 'imn,in-&gt;im')\nop.as_matrix()\nArray([[ 0,  1,  2,  3,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 4,  5,  6,  7,  0,  0,  0,  0,  0,  0,  0,  0],\n       [ 0,  0,  0,  0,  8,  9, 10, 11,  0,  0,  0,  0],\n       [ 0,  0,  0,  0, 12, 13, 14, 15,  0,  0,  0,  0],\n       [ 0,  0,  0,  0,  0,  0,  0,  0, 16, 17, 18, 19],\n       [ 0,  0,  0,  0,  0,  0,  0,  0, 20, 21, 22, 23]], dtype=int32)\n \nPart 2: Using JAX ecosystem for Minimization and Machine Learning Tools\n\nObjective: Apply gradient descent to the DenseBlockDiagonalOperator matrix.\nApproach:\n\nRetrofit the operator into the JAX ecosystem.\nLeverage JAX’s automatic differentiation for efficient gradient computation."
  },
  {
    "objectID": "csi2024/index.html#summary-of-projects-1",
    "href": "csi2024/index.html#summary-of-projects-1",
    "title": "CSI Presentation 2024",
    "section": "Summary of projects",
    "text": "Summary of projects\n\n\n\n\nProjects"
  },
  {
    "objectID": "csi2024/index.html#weak-lensing---astrodeepaim",
    "href": "csi2024/index.html#weak-lensing---astrodeepaim",
    "title": "CSI Presentation 2024",
    "section": "Weak Lensing - AstroDeep/Aim",
    "text": "Weak Lensing - AstroDeep/Aim\n\n\n\n\nProjects"
  },
  {
    "objectID": "csi2024/index.html#weak-lensing---statistical-tools",
    "href": "csi2024/index.html#weak-lensing---statistical-tools",
    "title": "CSI Presentation 2024",
    "section": "Weak Lensing - Statistical Tools",
    "text": "Weak Lensing - Statistical Tools\n\n\n\n\n\n\n\nHubble eXtreme Deep Field\n\n\n\n\n\n\n\nHubble eXtreme Deep Field\n\n\n\n\n\\[\n-2 \\underbrace{\\log P(g, \\boldsymbol{\\beta} \\mid \\mathbf{d})}_{\\text{Posterior}} =\n\\sum_{\\vec{k}} \\left[\\underbrace{\\frac{\\left|\\mathbf{d} - f(g \\mid \\boldsymbol{\\beta}, z)\\right|^2}{N}}_{\\text{Likelihood}} + \\underbrace{\\frac{|g|^2}{\\mathcal{P}(\\boldsymbol{\\beta})}}_{\\text{Prior}}\\right]_{\\vec{k}}\n\\]\n\n\n\n\n\n\nPrediction\n\n\n\n\n\n\n\n\n\n\n\n\n\nGaussian field\n\n\n\n\n \n\n\n\n\n\nLPT Field\n\n\n\n\n \n\n\n\n\n\nGalaxies\n\n\n\n\n\n\n\n\n\nInference"
  },
  {
    "objectID": "csi2024/index.html#hearchical-bayesian-modeling",
    "href": "csi2024/index.html#hearchical-bayesian-modeling",
    "title": "CSI Presentation 2024",
    "section": "Hearchical Bayesian Modeling",
    "text": "Hearchical Bayesian Modeling\n\n\n\n\n\nProbabilistic Graphical Model\n\n\n\n➕  No longer need to compute the likelihood analytically   ➖  We need to infer the joint posterior \\(p(\\beta, g | z)\\) before marginalization to get \\(p(\\beta | g) = \\int p(\\beta, z | g) \\, dz\\)\n\n\n\n\n\nPossible solutions\n\n\n\nHamiltonian Monte Carlo\nVariational Inference\nDimensionality reduction using Fisher Information Matrix\n\nAll require a differentiable fast forward model"
  },
  {
    "objectID": "csi2024/index.html#fast-particle-mesh-simulations",
    "href": "csi2024/index.html#fast-particle-mesh-simulations",
    "title": "CSI Presentation 2024",
    "section": "Fast Particle-mesh simulations",
    "text": "Fast Particle-mesh simulations\n \n\n\nNumerical scheme\n\n➢  Interpolate particles on a grid to estimate mass density\n\n\n➢  Estimate gravitational force on grid points by FFT\n\n\n➢  Interpolate forces back on particles\n\n\n➢  Update particle velocity and positions, and iterate\n\n\n\n\n\n\n\n\n\\(\\begin{array}{c}{{\\nabla^{2}\\phi=-4\\pi G\\rho}}\\\\\\\\ {{f(\\vec{k})=i\\vec{k}k^{-2}\\rho(\\vec{k})}}\\end{array}\\)\n\n\n\n\n\n\n\n\n     \n\n\n\nFast and simple, at the cost of approximating short range interactions.\nIt is essentially a series of FFTs and interpolations\nIt is differentiable and can run on GPUs\n\n\n\n\n\n\n\nCSI Presentation 2024"
  },
  {
    "objectID": "marseille2024/index.html#traditional-cosmological-inference",
    "href": "marseille2024/index.html#traditional-cosmological-inference",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "Traditional cosmological inference",
    "text": "Traditional cosmological inference\n\nBayesian inference in cosmology\n\nWe need to infer the cosmological parameters \\(\\theta\\) that generated an observartion \\(x\\)\n\n\\[p(\\theta | x ) \\propto \\underbrace{p(x | \\theta)}_{\\mathrm{likelihood}} \\ \\underbrace{p(\\theta)}_{\\mathrm{prior}}\\]\n\n\n\n\n\n\n\n\n\n\n ➢  Compute summary statistics based on the 2-point correlation function of the shear field\n\n\n ➢  Run an MCMC chain to recover the posterior distribution of the cosmological parameters, using an analytical likelihood\n\n\n\n\n\n\n\nLimitations\n\n\n\nSimple summary statistics assume Gaussianity\nThe need to compute an analytical likelihood"
  },
  {
    "objectID": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration",
    "href": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "JAX : Automatic differentiation and Hardware acceleration",
    "text": "JAX : Automatic differentiation and Hardware acceleration\n\n     \nimport numpy as np\n\n\ndef multiply_and_add(a, b, c):\n    return np.dot(a, b) + c\n\n\na, b, c = np.random.normal(size=(3, 32, 32))\nresult = multiply_and_add(a, b, c)\n\n\nimport jax\nimport jax.numpy as jnp\n\n\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c)"
  },
  {
    "objectID": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration-1",
    "href": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration-1",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "JAX : Automatic differentiation and Hardware acceleration",
    "text": "JAX : Automatic differentiation and Hardware acceleration\n\n     \nimport jax\nimport jax.numpy as jnp\n\n\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c)"
  },
  {
    "objectID": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration-2",
    "href": "marseille2024/index.html#jax-automatic-differentiation-and-hardware-acceleration-2",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "JAX : Automatic differentiation and Hardware acceleration",
    "text": "JAX : Automatic differentiation and Hardware acceleration\n\n     \nimport jax\nimport jax.numpy as jnp\n\n@jax.jit\ndef multiply_and_add(a, b, c):\n    return jnp.dot(a, b) + c\n\n\nkey = jax.random.PRNGKey(0)\na, b, c = jax.random.normal(key, (3, 32, 32))\n\nresult = multiply_and_add(a, b, c) \ngradient = jax.grad(multiply_and_add)(a, b, c)\n \n\n\nJAX : Numpy + Autograd + GPU\n\n\n\njax.grad uses automatic differentiation to compute the gradient of the function\njax.jit compiles the function to run on GPUs"
  },
  {
    "objectID": "marseille2024/index.html#distributed-fast-fourier-transform",
    "href": "marseille2024/index.html#distributed-fast-fourier-transform",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "Distributed Fast Fourier Transform",
    "text": "Distributed Fast Fourier Transform\n➢  only operation that requires communication is the FFT\n\nJaxdecomp\n\n\nimport jax\nimport jax.numpy as jnp\n\nfield = jax.random.normal(jax.random.PRNGKey(0), (1024, 1024, 1024))\nk_field = jnp.fft.fftn(field)"
  },
  {
    "objectID": "marseille2024/index.html#distributed-fast-fourier-transform-1",
    "href": "marseille2024/index.html#distributed-fast-fourier-transform-1",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "Distributed Fast Fourier Transform",
    "text": "Distributed Fast Fourier Transform\n➢  only operation that requires communication is the FFT\n\nJaxdecomp\n\n DifferentiableUniverseInitiative/jaxDecomp\n\n\n\nimport jax\nimport jax.numpy as jnp\nimport jaxdecomp\n\ndevices = mesh_utils.create_device_mesh((2, 2))\nmesh = jax.sharding.Mesh(devices, axis_names=('x', 'y'))\nsharding = jax.sharding.NamedSharding(mesh, P('x', 'y'))\n\n# Create gaussian field distributed across the mesh\nfield = jax.make_array_from_single_device_arrays(\n    shape=mesh_shape,\n    sharding=sharding,\n    arrays=[jax.random.normal(jax.random.PRNGKey(rank), (512, 512, 1024))])\n\nk_field = jaxdecomp.fft.pfft3d(field)\n\n\n\n\nJaxDecomp features\n\n\n➢  jaxDecomp supports 2D and 1D decompositions\n➢  Works for multi-node FFTs\n➢  is differentiable\n➢  The package is also provided as a standalone library"
  },
  {
    "objectID": "marseille2024/index.html#halo-exchange-in-distributed-simulations",
    "href": "marseille2024/index.html#halo-exchange-in-distributed-simulations",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "Halo exchange in distributed simulations",
    "text": "Halo exchange in distributed simulations\n\n\n\n\n\n\n\n\n\n\n\nInitial Field\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst slice\n\n\n\n\n\n\n\n\n\nSecond slice\n\n\n\n\n\n\n\n\n\nThird slice\n\n\n\n\n\n\n\n\n\nFourth slice\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst slice\n\n\n\n\n\n\n\n\n\nSecond slice\n\n\n\n\n\n\n\n\n\nThird slice\n\n\n\n\n\n\n\n\n\nFourth slice\n\n\n\n\n\n\n\n\n\n\nLPT Field\n\n\n\n\n\n\n\nLPT Field\n\n\n\n\n\n\nfrom jaxdecomp import halo_exchange\n\nhalo_size = 128\nfield = halo_exchange(field, halo_extent=halo_size)"
  },
  {
    "objectID": "marseille2024/index.html#conclusion",
    "href": "marseille2024/index.html#conclusion",
    "title": "Differentiable and distributed Particle-Mesh n-body simulations",
    "section": "Conclusion ",
    "text": "Conclusion \n   \n\n\nDistruibuted Particle-Mesh simulations for cosmological inference\n\n\n\nA shift from analytical likelihoods to full field inference\n\nThe need for fast differentiable simulators\nParticle-Mesh as simulators for full field inference\nDistributed fourrier transforms that work on multi-node HPC using jaxDecomp\nHighly scalable LPT simulations using JaxPM\n\nStill subject to some challenges\n\nSome issues with the ODE solving step\nOnly Euler gives decent results.\n\n\n\n\n\n\n\nLSST France, 2024"
  }
]